Aeron  is an efficient and reliable peer-to-peer message transport. It provides a replicated persistent log of messages via a number of media drivers, including HTTP, UDP and TCP. It also supports persistent storage of message streams for later replay. For many applications, Aeron may be overkill because it operates at a pretty low level (OSI Layer 4 conceptually), but it&#39;s peer-to-peer design and low (and predictable) latency are useful in a number of use cases. Indeed, we&#39;ve found it to be useful in certain machine learning applications as well as playing a part in event-driven architectures. We think it&#39;s worth pointing out that alternative messaging protocols exist that don&#39;t require additional services such as  Apache Kafka  to be run. 
Networking and decoding in iOS applications have been a difficult endeavor for many years. There have been many libraries and attempts to solve this ongoing problem. It looks as though  Alamofire  is the most robust and developer-friendly library to handle decoding JSON. It was written by the same creator as its Objective-C counterpart (AFNetworking), which was used at great length during the Objective-C days. 
Historically, Google&#39;s Android documentation examples lacked architecture and structure. This changes with the release of  Android Architecture Components  , a set of opinionated libraries that help developers create Android applications with better architecture. They address longstanding pain points of Android development: handling lifecycles; pagination; SQLite databases; and data persistence over configuration changes. The libraries don&#39;t need to be used together â€” you can pick the ones you need most and integrate them into your existing project. Historically, Google&#39;s Android documentation examples lacked architecture and structure. This changes with the release of  Android Architecture Components , a set of opinionated libraries that help developers create Android applications with better architecture. They address longstanding pain points of Android development: handling lifecycles; pagination; SQLite databases; and data persistence over configuration changes. The libraries don&#39;t need to be used together â€” you can pick the ones you need most and integrate them into your existing project. 
In previous Radar editions, we&#39;ve been hesitant to give  Angular  a strong recommendation because it was essentially a new, and on the whole unexciting, framework, sharing only its name with AngularJS, an older framework we loved in days past. In the meantime, Angular, now in version 5, has improved steadily while providing backward compatibility along the way. Several of our teams have Angular applications in production and reportedly, they like what they see. For this reason, we&#39;re moving Angular into the Trial ring in this Radar, to signify that some of our teams now consider it a solid choice. Most of our teams, however, still prefer  React ,  Vue  or  Ember  over Angular. In the previous Radar, we moved  AngularJS  into the Hold ring (where it remains in this edition). When it comes to  Angular 2 , we&#39;re seeing mixed messages. Over the past year some teams at ThoughtWorks have used Angular 2 successfully and consider it a solid choice. However, Angular 2 is a rewrite, not an evolution, of AngularJS, and switching from AngularJS to Angular 2 is not much different than switching from AngularJS to another framework. Given the, in our experience, superior contenders such as  React.js ,  Ember.js  and  Vue.js , we&#39;re still hesitant to give Angular 2 a strong recommendation. We do want to highlight, though, that it is not a bad choice, especially if you bought into TypeScript. 
We are seeing a common pattern of creating single-page web applications. Rather than requiring full page refresh, these request smaller sets of data from the server, and change the displayed content of their page through modifying the DOM. To make this more manageable, JavaScript MV* frameworks have been developed that support data binding, client-side templates, and validation. While lightweight applications may not need a framework, for more complex scenarios, AngularJS and Knockout should be considered as the current front-runners in this field. 
AngularJS  helped revolutionize the world of single-page JavaScript applications, and we have delivered many projects successfully with it over the years. However, we are no longer recommending it (v1) for teams starting fresh projects. We prefer the ramp-up speed and more maintainable codebases we are seeing with  Ember  and  React , particularly in conjunction with  Redux . AngularJS  helped revolutionize the world of single-page JavaScript applications, and we have delivered many projects successfully with it over the years. However, we are no longer recommending it (v1) for teams starting fresh projects. We prefer the ramp-up speed and more maintainable codebases we are seeing with  Ember  and  React , particularly in conjunction with  Redux . While we have delivered many successful projects using  AngularJS  and are seeing an acceleration of adoption in corporate settings, we have decided to move Angular back to Assess on this edition of the Radar. This move is intended as a note of caution:  React.js  and  Ember  offer strong alternatives; the migration path from Angular version 1 to version 2 is causing uncertainty; and we see some organizations adopting the framework without really thinking through whether a single-page application fits their needs. We have passionate internal debates about this topic but have certainly seen codebases become overly complex from a combination of two-way binding and inconsistent state-management patterns. We believe that rather than requiring that a solid framework be jettisoned, these issues can be solved through careful design and use of Redux or Flux from the outset. We continue to see JavaScript frameworks as a useful way to structure code and bring better coding techniques to JavaScript.  AngularJS  is used widely by ThoughtWorks projects. However, we are a bit concerned about the future of the framework.  The 2.0 version currently under development represents a ground-up redesign that some might not be happy with.  Without an evolutionary migration path, maintainers of existing AngularJS applications will be forced to either live with an unsupported version or undertake a large rewrite.  We advise teams to first assess their requirements to understand if a single-page JavaScript application is really necessary.  In many cases, a traditional page-model app is simpler to write and easier to maintain.  Remember that there are other good alternatives to AngularJS, such as Ember.js, Knockout.js, and React.js. We continue to see JavaScript frameworks as a useful way to structure code and bring better coding techniques to JavaScript.  AngularJS  is used widely by ThoughtWorks projects. However we do advise teams to assess other good alternatives such as Ember.js and Knockout.js. 
Apache Beam  is an open-source unified programming model for defining and executing both batch and streaming data parallel processing pipelines. The Beam model is based on the  Dataflow model  which allows us to express logic in an elegant way so that we can easily switch between batch, windowed batch or streaming. The big data-processing ecosystem has been evolving quite a lot which can make it difficult to choose the right data-processing engine. One of the key reasons to choose Beam is that it allows us to switch between different runners â€” a few months ago  Apache Samza  was added to the other runners it already supports, which include  Apache Spark ,  Apache Flink  and  Google Cloud Dataflow . Different runners have different capabilities and providing a portable API is a difficult task. Beam tries to strike a delicate balance by actively pulling innovations from these runners into the Beam model and also working with the community to influence the roadmap of these runners. Beam has SDKs in multiple languages including Java, Python and Golang. We&#39;ve also had success using  Scio  which provides a Scala wrapper around Beam. Apache Beam  is an open source unified programming model for defining and executing both batch and streaming data-parallel processing pipelines. Beam provides a portable API layer for describing these pipelines independent of execution engines (or runners) such as  Apache Spark ,  Apache Flink  or  Google Cloud Dataflow . Different runners have different capabilities and providing a portable API is a difficult task. Beam tries to strike a delicate balance by actively pulling innovations from these runners into the Beam model and also working with the community to influence the roadmap of these runners. Beam has a rich set of  built-in I/O transformations  that cover most of the data pipeline needs and it also provides a mechanism to implement  custom transformations  for specific use cases. The portable API and extensible IO transformations make a compelling case for assessing Apache Beam for data pipeline needs. 
Our teams report that  Apollo  has become the library of choice when building a  React  application that uses GraphQL to access data from a  back-end  service. Although the Apollo project also provides a server framework and a GraphQL gateway, the Apollo client gets our attention because it simplifies the problem of binding UI components to data served by any GraphQL backend. Put simply, this means less code needs to be written than using REST backends and redux. Since it was first introduced in the Radar, weâ€™ve seen a steady adoption of  GraphQL , particularly as a remote interface for a  Backend for Frontend (BFF) . As they gain more experience, our teams have reached consensus on Apollo, a GraphQL client, as the preferred way to access GraphQL data from a  React  application. Although the  Apollo  project also provides a server framework and a GraphQL gateway, the Apollo client simplifies the problem of binding UI components to data served by any GraphQL backend. Notably, Apollo is used by Amazon AWS in their recent launch of the new  AWS AppSync service . 
We&#39;ve seen a flurry of activity in mobile augmented reality much of it fueled by  ARKit and ARCore , the native AR libraries used by  Apple  and  Google , respectively. These libraries are bringing mobile AR technologies to the mainstream. However, the challenge will be for companies to find use cases that go beyond gimmicky and provide genuine solutions that actually enhance the user experience. 
Arrow  is promoted as the functional companion for  Kotlin&#39;s standard library . Indeed, the package of ready-to-use higher-level abstractions delivered by Arrow has proven so useful that our teams now consider Arrow a sensible default when working with Kotlin. Recently, in preparation for the 1.0 release, the Arrow team introduced several changes, including the addition of new modules but also some deprecations and removals. Arrow  is a functional programming library for  Kotlin , created by merging two existing popular libraries ( kategory  and  funKTionale ). While Kotlin provides building blocks for functional programming, Arrow delivers a package of ready-to-use higher-level abstractions for application developers. It provides data types, type classes, effects, optics and other functional programming patterns as well as integrations with popular libraries. Our initial positive impressions of Arrow were confirmed when using it to build applications that are now in production. Arrow  is a functional programming library for  Kotlin , created by merging two existing popular libraries ( kategory  and  funKTionale ). While Kotlin provides building blocks for functional programming, Arrow delivers a package of ready-to-use higher-level abstractions for application developers. It provides data types, type classes, effects, optics and other functional programming patterns as well as integrations with popular libraries. With Arrow, existing libraries are unified, which should go a long way to avoid fractured communities in this space. 
AssertJ  is a Java library that provides a  fluent interface  for assertions, which makes it easy to convey intent within test code. AssertJ gives readable error messages, soft assertions and improved collections and exception support. Many of our teams choose AssertJ as their default assertion library instead of JUnit combined with  Java Hamcrest . AssertJ  is a Java library that provides a  fluent interface  for assertions, which makes it easy to convey intent within test code. AssertJ gives readable error messages, soft assertions, and improved collections and exception support. We&#39;re seeing some teams default to its use instead of JUnit combined with Hamcrest. 
A multi-app strategy is really controversial, particularly at a time when fewer and fewer users are downloading new apps. Instead of introducing a new app and struggling with the download numbers, multiteams have to deliver functionality via a single app that is already widely installed, which creates an architectural challenge.  Atlas  and  BeeHive  are modularization solutions for Android and iOS apps, respectively. Atlas and BeeHive enable multiteams working on physically isolated modules to reassemble or dynamically load these modules from a facade app. Both are Alibaba open source projects, since Alibaba encountered the same problem of dwindling downloads and single-app architectural challenges. A multi-app strategy is really controversial, particularly at a time when fewer and fewer users are downloading new apps. Instead of introducing a new app and struggling with the download numbers, multiteams have to deliver functionality via a single app that is already widely installed, which creates an architectural challenge.  Atlas  and  BeeHive  are modularization solutions for Android and iOS apps, respectively. Atlas and BeeHive enable multiteams working on physically isolated modules to reassemble or dynamically load these modules from a facade app. Both are Alibaba open source projects, since Alibaba encountered the same problem of dwindling downloads and single-app architectural challenges. 
Aurelia  is considered the next-generation JavaScript client framework and was written using a modern version of JavaScript: ECMAScript 2016. Aurelia was created by Rob Eisenberg, the creator of  Durandal . He left the  Angular 2.0  core team to dedicate his time to this project. The great thing about Aurelia is that it&#39;s highly modular, contains simple small libraries and is designed to be customized easily. Aurelia follows the pattern of convention over configuration, which enables easier production and consumption of modules, but there are no strong conventions that you have to adhere to. Aurelia has a large community, and in the project website you can learn more by using the tutorials. 
Avro  is a framework for data serialization. By storing schema along with the message content, it encourages schema evolution. Producers can edit field names, add new fields or delete existing fields and Avro guarantees that the clients continue to consume the messages. Having a schema allows data to be written without overhead which results in compact data encoding and faster data processing. Although the exchange of structure-less messages between producer and consumer is flexible, we&#39;ve seen teams facing issues with incompatible unprocessed messages in the queue during deployments. We&#39;ve used Avro in a number of projects and would recommend using it over just sending unstructured messages. Avro  is a framework for data serialization. By storing schema along with the message content, it encourages schema evolution. Producers can edit field names, add new fields or delete existing fields and Avro guarantees that the clients continue to consume the messages. Having a schema allows data to be written without overhead which results in compact data encoding and faster data processing. Although the exchange of structure-less messages between producer and consumer is flexible, we&#39;ve seen teams facing issues with incompatible unprocessed messages in the queue during deployments. We&#39;ve used Avro in a number of projects and would recommend using it over just sending unstructured messages. 
While we still have some reservations about  CQRS  as a general pattern, the approach can work very well in specific places. In those specific situations, however, a lot of work is left to the developer to properly execute CQRS.  Axon  is a framework that can help with this on the JVM, and weâ€™ve used it with some success. Although it certainly canâ€™t be considered a perfect solution right now, it continues to evolve and may make much more sense than trying to write everything from scratch. 
When we wrote about  VR beyond gaming  a few years ago we made no prediction on how quickly and to what extent VR solutions would be found in fields other than video gaming. In hindsight, we&#39;ve certainly seen interest and adoption grow but the uptake has been slower than some of us anticipated. One reason could be tooling.  Unity  and  Unreal  are two very mature and capable engines for developing VR applications. We also highlighted  Godot . However, these engines are quite unlike what most web and enterprise teams are familiar with. As we continued exploring, we realized that web-based VR solutions have come a long way and we&#39;ve had positive experience with  Babylon.js . Written in TypeScript and rendering its applications in the browser, Babylon.js provides a familiar experience for many development teams. Additionally, Babylon.js is open-source software, mature and well-funded, which makes it even more attractive. 
Backbone.js is a great example of an abstraction pushed too far. While we initially liked the ease of wire-up, in practice it suffers from the same issues as all such databound frameworks from WebForms to client/server tools. We find that it blurs the framework and model too much, forcing either bad architectural decisions or elaborate framework hackery in order to preserve sanity. Even though JavaScript increasingly plays a more important role in todayâ€™s world of software development, it is still troublesome to organize in a clean structure. Backbone.js is a library which provides an MVC (model view controller) framework for JavaScript heavy applications. It allows developers to write JavaScript code in a more manageable and testable way. 
Although JavaScript and its ecosystem is dominant in the web UI development space, new opportunities are opening up with the emergence of  WebAssembly . We see  Blazor  as an interesting option for building interactive web UIs using C#. We especially like this open-source framework because it allows running C# code in the browser on top of WebAssembly, leveraging the .NET Standard runtime and ecosystem as well as custom libraries developed in this programming language. Additionally, it can interoperate bidirectionally with JavaScript code in the browser if needed. 
Butterknife  is a fieldÂ and methodÂ binding view-injection library. It allows the injection of arbitrary objects, views and listeners, thereby ensuring cleaner code with reduced glue code for Android development. With Butterknife, multiple views can be grouped into a list or array with common actions applied to the views simultaneously, without heavy reliance on XML configurations. Our project teams have used this library and benefited from its simplicity and ease of use. 
When C# first appeared, many saw it as a direct competitor to the Java languageâ€™s dominance in enterprise application development. This was often attributed to the syntactical similarities that the two languages shared. Since its introduction, however, C# has continued to move forward with the adoption of language features such as lambda expressions, extension methods, object initializers and automatic property setters and getters, all of which are available in the 3.5 release of the language. With the 4.0 release of C#, we will see the introduction of a dynamic keyword and named and optional parameters, which will continue to bring C# more in line with languages such as Ruby and well ahead of the Java language. 
Caffe  is an open source library for deep learning created by the  Berkeley Vision and Learning Center . It mostly focusses on convolutional networks for computer vision applications. Caffe is a solid and popular choice for computer vision-related tasks and you can download many successful models made by Caffe users from the Caffe Model Zoo for out-of-the-box use. Like  Keras , Caffe is a Python-based API. In Keras, however, models and components are objects created directly in Python code, whereas Caffe models are described by  Protobuf  configuration files. Either approach has its pros and cons, and converting between the two is also possible. Caffe  is an open source library for deep learning created by the  Berkeley Vision and Learning Center . It mostly focusses on convolutional networks for computer vision applications. Caffe is a solid and popular choice for computer vision-related tasks and you can download many successful models made by Caffe users from the Caffe Model Zoo for out-of-the-box use. Like  Keras , Caffe is a Python-based API. In Keras, however, models and components are objects created directly in Python code, whereas Caffe models are described by  Protobuf  configuration files. Either approach has its pros and cons, and converting between the two is also possible. 
We tend to be quite skeptical of business process model and notation (BPMN) tools in general as they&#39;re often associated with low-code environments and their downsides. Although the OSS BPMN framework  Camunda  provides some of this whizziness, it also offers workflow and decision engines that can be directly integrated as a library in your Java code. This makes it easy to test, version and refactor workflows. Camunda also integrates with Spring and Spring Boot, among other frameworks, making it a solid choice. 
The industry is experiencing something of a renaissance in programming languages. ThoughtWorks thinks it is time to start assessing which other languages will help your organization while taking stock of the useful lifetime remaining for your current choices. You need to care about languages. Traditionally structured organizations with separate support teams may find skills constrain choice, DevOps offers a path forwards here. 
The  Chaos Toolkit  is one of a number of  Chaos Engineering  tools that made this edition of the Radar. You use the toolkit to describe and then run repeatable experiments on your infrastructure to understand its resilience in the event of failure. Many of our teams have been using homegrown tools to do this, so it&#39;s great to see an open-source project dedicated to the practice. The toolkit already has drivers for  AWS ,  Azure Service Fabric  and GCE (among others) and plays nicely with build tools which lets you experiment with automation. The usual caveats apply though, Chaos Engineering is a very powerful technique that is best used on resilience-aware systems, that is, systems that have been built to cope with failure. For that reason, we recommend starting using Chaos Toolkit in your nonproduction environments first. 
Our first rule of thumb in selecting a rules engine is normally: you don&#39;t need a rules engine. We&#39;ve seen too many people tying themselves to a hard-to-test black-box rules engine for spurious reasons, when custom code would have been a better solution. That said, we&#39;ve had success using  Clara rules  for scenarios where a rules engine does make sense. We like that it uses simple Clojure code to express and evaluate the rules, which means they are amenable to refactoring, testing and source control. Rather than chasing the illusion that business people should directly manipulate the rules, it drives collaboration between the business experts and developers. Our first rule of thumb in selecting a rules engine is normally: you don&#39;t need a rules engine. We&#39;ve seen too many people tying themselves to a hard-to-test black-box rules engine for spurious reasons, when custom code would have been a better solution. That said, we&#39;ve had success using  Clara rules  for scenarios where a rules engine does make sense. We like that it uses simple Clojure code to express and evaluate the rules, which means they are amenable to refactoring, testing and source control. Rather than chasing the illusion that business people should directly manipulate the rules, it drives collaboration between the business experts and developers. 
With the aim of improving performance in our code, profiling tools are very useful to identify bottlenecks or delays in code which are hard to identify, especially in asynchronous operations.  Clinic.js Bubbleprof  represents visually the async operations in Node.js processes, drawing a map of delays in the application&#39;s flow. We like this tool because it helps developers to easily identify and prioritize what to improve in the code. 
Clojure is a dynamic, functional language that runs on the JVM. Although its roots are in Lisp, one of the oldest computer languages, it also embodies many modern programming concepts, including lazy evaluation and advanced concurrency abstractions. Clojure has spawned a vibrant community of programmers who are contributing a rich set of frameworks and tools. One example of these is Midje, an innovative spin on unit testing and mocking frameworks. The functional languages F#, Clojure and Scala still reside in the assess ring of the radar. Interest in functional languages continues to grow. Two characteristics of functional languages in particular are driving this interest, immutability with its implications for parallelism and functions as first class objects. While the introduction of closures to C# brings some of the latter capability, functional languages are almost synonymous with immutability. The placement of these languages within the assess ring indicates our view of their relative maturity and appropriateness. F#, based on OCaml, is fully supported within the Visual Studio toolset. F# includes support for objects and imperative constructs in addition to functional language constructs in a natural way. Scala, like F#, combines the object and functional paradigms, although the syntax of Scala is more Java-like. Clojure began as a JVM language and is now available on the .NET CLR. Clojure does allow for mutable state although it has an extensive set of immutable persistent data structures, all supporting multi-threaded applications. There are many similarities between these three languages, but at the moment we believe F# and Clojure to be better suited to most organizations for assessing than Scala. More work clearly needs to be done to validate this assertion. In the previous radar, we lumped functional languages together in a group. For this version, weâ€™ve exploded that group and started calling out the ones interesting to us. Of the current crop of functional languages, the one we like the most is Clojure: a simple, elegant implementation of Lisp on the JVM. The other two that we fi nd interesting are Scala (a re-thinking of Java in functional form) and F#, the OCaml derivative from Microsoft that now appears â€œin the boxâ€� in Visual Studio 2010. 
ClojureScript illustrates just how cross-platform the core of Clojure really is: they ported the primary parts to run on JavaScript. It is missing some of the whizzbang features of Clojure on the JVM and CLR, like software transactional memory, but has a surprisingly high fidelity with its more sophisticated cousins. One interesting option afforded by ClojureScript is the ability to send data structures Ã  la JSON using ClojureScript as the data structure. Because Clojure is a Lisp, this means that you can also send â€œrealâ€� code. 
The expansion of single-page and mobile browser-based applications into mainstream use, along with continued growth of node.js for server-side applications, have led to increased adoption of CoffeeScript to simplify JavaScript codebases. As a language that compiles into JavaScript code for runtime execution, many concerns have been raised about the difficulty of debugging applications written in CoffeeScript. The introduction of Source Maps in CoffeeScript 1.6.1 is helping producers of development tools address this concern.  We expect this will lead to further adoption of the language following the lead of highly visible technology firms such as Dropbox. JavaScript is a powerful, ubiquitous programming language with tricky and error prone syntax. Coffeescript fixes many of the warts of JavaScript in a clean, simple syntax that generates readable JavaScript. For example, creating true private variables in JavaScript is a syntactic nightmare; CoffeeScript generates the technically correct but hideous syntax. Some readers may be confused by our advocacy of Coffeescript given our general dislike for GWT, because on the surface they seem similar: tools that generate JavaScript. However, it is the level of abstraction that differs. GWT has an elaborate component model, which tries to hide details about the underlying language (JavaScript) and platform (the web). Coffeescript tries to make it easier to write proper JavaScript, avoiding pathological but default â€œfeaturesâ€� of JavaScript, and does not build a layer that tries to insulate you from the platform. 
As the industry shifted from desktop GUI development to the web, it seemed natural to port the most successful patterns and designs to the new paradigm. After 15 years of trying, we feel that there are still no component-based frameworks that have successfully achieved this. We recommend not attempting to make web development into something that it fundamentally is not. It is time to accept the page and request-based nature of the web, and focus on the frameworks that support - rather than work against - these concepts. 
The remaining two language types included on the radar are often grouped together. While functional and concurrent languages may be adopted in similar environments, their approaches are different. Functional programming focuses on expressing code in the form of mathematical functions that avoid maintaining state across multiple invocations. While functional languages such as Haskell have been around for a number of years, new functional (themed) languages such as Scala, F# and Clojure have sparked some interest in this paradigm. Due to the way in which functional languages manage state, interest in these languages has increased by many developers seeking to make the most out of multi-core processors. Many concurrent languages are also functional languages. The distinction lies in the emphasis on running operations in parallel. A number of such languages exist; Erlang is currently the most popular of these languages. Concurrent languages commonly provide some means for handling concurrency by using messages to communicate across multiple threads. 
The Clojure  core.async  library allows asynchronous communication using channels, with similar syntax and capabilities to Google&#39;s Go language. The core.async library solves many common problems in an elegant way, cleaning up event callback setup and adding simple concurrency primitives. It also highlights one of the advantages of the Lisp nature of Clojure: channels add operators that are consistent with existing Clojure operators, seamlessly weaving new functionality into the language core. In addition, core.async is supported in both Clojure and ClojureScript (despite JavaScript&#39;s lack of threads), utilizing underlying platform abstractions to provide a consistent interface to both languages. The Clojure  core.async  library allows asynchronous communication using channels, with similar syntax and capabilities to Google&#39;s Go language. The core.async library solves many common problems in an elegant way, cleaning up event callback setup and adding simple concurrency primitives. It also highlights one of the advantages of the Lisp nature of Clojure: channels add operators that are consistent with existing Clojure operators, seamlessly weaving new functionality into the language core. In addition, core.async is supported in both Clojure and ClojureScript (despite JavaScript&#39;s lack of threads), utilizing underlying platform abstractions to provide a consistent interface to both languages. 
This language/framework was included in this edition of the Radar for visibility. We felt that there wasn&#39;t anything substantial to add to the discourse around it, but that it was important to keep this in view. 
CSS is the preferred choice for laying out web pages, even when it did not provide much explicit support for creating layouts. Flexbox helped with simpler, one-dimensional layouts, but developers usually reached for libraries and toolkits for more complex layouts.  CSS Grid Layout  is a two-dimensional grid-based layout system that provides a mechanism to divide available space for layout into columns and rows using a set of predictable sizing behaviors. Grid does not require any libraries and plays well with Flexbox and other CSS display elements. However, since IE11 is only  partially supported , it ignores users who still depend on a Microsoft browser on Windows 7. CSS is the preferred choice for laying out web pages, even when it did not provide much explicit support for creating layouts. Flexbox helped with simpler, one-dimensional layouts, but developers usually reached for libraries and toolkits for more complex layouts.  CSS Grid Layout  is a two-dimensional grid-based layout system that provides a mechanism to divide available space for layout into columns and rows using a set of predictable sizing behaviors. Grid does not require any libraries and plays well with Flexbox and other CSS display elements. However, since IE11 is only  partially supported , it ignores users who still depend on a Microsoft browser on Windows 7. 
Since we first mentioned  CSS-in-JS  as an emerging technique in 2017, it has become much more popular, a trend we also see in our work. With some solid production experience under our belts, we can now recommend CSS-in-JS as a technique to trial. A good starting point is the  styled components  framework, which we mentioned in our previous Radar. Next to all the positives, though, there usually is a downside when using CSS-in-JS: the calculation of styles at runtime can cause a  noticeable lag for end users . With  Linaria  we&#39;re now seeing a new class of frameworks that were created with this issue in mind. Linaria employs a number of techniques to shift most of the performance overhead to build time. Alas, this does come with its own set of trade-offs, most notably a lack of dynamic style support in IE11. CSS in JS  is a technique of writing CSS styling in the JavaScript programming language. This encourages a common pattern of writing the styling with the JavaScript component it applies to, co-locating presentational and logical concerns. The new players â€” including  JSS ,  emotion  and  styled-components  â€” rely on the tooling to translate the CSS-in-JS code to separate CSS stylesheets, to make them suitable for browser consumption. This is the second-generation approach to writing CSS in JavaScript and unlike the previous approaches doesnâ€™t rely on in-line styles. That means it provides the benefit of supporting all CSS features, sharing of CSS using the  npm  ecosystem and utilization of components across multiple platforms. Our teams have found  styled-components  working well with component-based frameworks, such as  React , and unit testing of CSS with  jest-styled-components . This space is new and rapidly changing; the approach requires some effort for manual debugging of the generated class names in the browser, and it may not apply to some projects where the front-end architecture does not support reusing components and requires global styling. 
Most large CSS codebases require complex naming schemes to help avoid naming conflicts in the global namespace.  CSS Modules  address these problems by creating a local scope for all class names in a single CSS file. This file is imported to a JavaScript module, where CSS classes are referenced as strings. Then, in the build pipeline (Webpack, Browserify, etc.), the class names are replaced with generated unique strings. This is a significant change in responsibilities. Previously, a human had to manage the global namespace, to avoid class naming conflicts; now that responsibility rests with the build tooling. A small downside we&#39;ve encountered with CSS Modules: functional tests are usually out of the local scope and can therefore not reference classes by the name defined in the CSS file. We recommend using IDs or data attributes instead. Most large CSS codebases require complex naming schemes to help avoid naming conflicts in the global namespace.  CSS Modules  address these problems by creating a local scope for all class names in a single CSS file. This file is imported to a JavaScript module, where CSS classes are referenced as strings. Then, in the build pipeline (Webpack, Browserify, etc.), the class names are replaced with generated unique strings. This is a significant change in responsibilities. Previously, a human had to manage the global namespace, to avoid class naming conflicts; now that responsibility rests with the build tooling. A small downside we&#39;ve encountered with CSS Modules: functional tests are usually out of the local scope and can therefore not reference classes by the name defined in the CSS file. We recommend using IDs or data attributes instead. 
The intersection between IoT devices and the JavaScript ecosystem offers interesting possibilities.  Cylon.js  is a JavaScript library for building interfaces for robotics and the Internet of Things, which has excited our technical community. It offers support for 50+ platform devices, as well as general-purpose input/output support with a shared set of drivers provided by the cylon-gpio module. Control of the devices is then possible through a web browser interface. 
With the increased need for Android-based applications,  Dagger   offers a fully static, compile-time dependency-injection framework. Dagger&#39;s strictly generated implementation and nonreliance on reflection-based solutions addresses many of the performance and development issues,Â thereby making it suitable for Android development. With Dagger, there is full traceability with easy debugging because the entire call stack for provision and creation is made available. 
Dapper  is a minimal, lightweight ORM of sorts for .NET. Rather than trying to write the SQL queries for you, Dapper maps SQL queries to dynamic objects. Though it&#39;s not brand new, Dapper has steadily gained acceptance from ThoughtWorks teams working in .NET. For the C# programmer, it removes some of the drudgery of mapping relational queries to objects while still allowing complete control over the SQL or stored procedures. 
The importance of big, visible displays in team areas has been written about many times before, and we certainly value the approach of helping everyone see and understand key pieces of information about how our software or our teams are doing.  Dashing  is a Ruby-based dashboard system we have been using for many years to create clear, visible displays optimized for large monitors. It is very hackable, allowing you to pull in information from a variety of sources from build systems, ticket or story tracking tools, or production monitoring systems.  
Data scientists and engineers often use libraries such as  pandas  to perform ad hoc data analysis. Although expressive and powerful, these libraries have one critical limitation: they only work on a single CPU and don&#39;t provide horizontal scalability for large data sets.  Dask , however, includes a lightweight, high-performance scheduler that can scale from a laptop to a cluster of machines. And because it works with  NumPy , pandas and  Scikit-learn , Dask looks promising for further assessment. 
DeepLearning.scala  is an open source deep-learning toolkit in Scala created by our colleagues at ThoughtWorks. We&#39;re excited about this project because it uses differentiable functional programming to create and compose neural networks; a developer simply writes code in Scala with static typing. DeepLearning.scala currently supports basic types such as float, double, GPU-accelerated N-dimensional arrays as well as algebraic data types. We&#39;re looking forward to future releases of the toolkit which are said to support higher order functions and distributed training on  Spark . 
There are still some tool gaps when applying good software engineering practices in data engineering. Attempting to automate data quality checks between different steps in a data pipeline, one of our teams was surprised when they found only a few tools in this space. They settled on  Deequ , a library for writing tests that resemble unit tests for data sets. Deequ is built on top of  Apache Spark , and even though it&#39;s published by AWS Labs it can be used in environments other than  AWS . 
Digdag  is a tool for building, running, scheduling and monitoring complex data pipelines in the cloud. You can define these pipelines in YAML, using either the rich set of out-of-the-box operators or building your own through the API. Digdag has most of the common features in a data pipeline solution such as dependency management, modular workflow to promote reuse, secured secret management and multilingual support. The feature we&#39;re most excited about is polycloud support, which lets you move and join data across AWS RedShift, S3, and Google  BigQuery . As more and more cloud providers offer competing data-processing solutions, we think Digdag (and similar tools) will be useful in leveraging the best option for the task. 
We have used the  Django REST framework , which is a flexible and customizable framework that makes it easy to build web APIs, in several of our projects. It allows you to build RESTful APIs in Python with Django, exposing API endpoints which are accessible from a consumer front-end. Django REST gives a browsable web API that allows developers to visualize data being transferred through the API and returns response examples, which the consumer application will receive. It provides a number of authentication schemes out of the box, and allows implementation of custom schemes. 
Domain-Specific Languages is an old technique that we think is significantly under-used. We hope that the publication of Martin Fowlerâ€™s latest book will encourage more people to utilize them. A significant amount of innovation occurred in the JavaScript space thanks to the Ruby on Rails community. This same community has helped to move both internal and external DSLs forward as a means for more closely mapping business requirements in code. Rubyâ€™s syntax lends itself easily to the creation of easily readable DSLs, while language tools such as ANTLR help to make the creation of new domain specific languages more accessible to interested developers. 
Dropwizard  is an opinionated combination of several lightweight Java tools and frameworks, many of which would merit mention in their own right. The package embodies many of our favorite techniques, including an embedded HTTP server, support for RESTful endpoints, built-in operational metrics and health-checks, and straightforward deployments. Dropwizard makes it easy to do the right thing, allowing you to concentrate on the essential complexity of a problem rather than the plumbing. 
Druid  is a JDBC connection pool with rich monitoring features. It has a built-in SQL parser, which provides semantic monitoring of the SQL statements executing in the database. Injections or suspicious SQL statements will be blocked and logged directly from the JDBC layer. Whatâ€™s more, queries can be merged based on their semantics. This is an Alibaba open source project, and reflects the lessons Alibaba learnt from operating their own database systems. 
ECharts  is a lightweight charting library with rich support for different types of charts and interactions. Since ECharts is entirely based on the  Canvas API , it has incredible performance even when dealing with over 100k data points, and it&#39;s also been optimized for mobile usage. Together with its sibling project,  ECharts-X , it can support 3D plotting. ECharts is a Baidu open source project. 
ECMAScript 2017 â€”not to be confused with ES7 (a.k.a. ECMAScript 2016)â€”brings several noteworthy improvements to the language. Browsers are expected to implement this standard fully in the summer of 2017, but the  Babel  JavaScript compiler already supports a number of the features today. If you make extensive use of JavaScript and your codebase is under active development, we recommend that you add Babel to your build pipeline and begin using the  supported features . ECMAScript 2017 â€”not to be confused with ES7 (a.k.a. ECMAScript 2016)â€”brings several noteworthy improvements to the language. Browsers are expected to implement this standard fully in the summer of 2017, but the  Babel  JavaScript compiler already supports a number of the features today. If you make extensive use of JavaScript and your codebase is under active development, we recommend that you add Babel to your build pipeline and begin using the  supported features . 
Interest in the  Elixir  programming language continues to build. Increasingly, we see it used in serious projects and hear feedback from developers who find its Actor model to be robust and very fast. Elixir, which is built on top of the Erlang virtual machine, is showing promise for creating highly concurrent and fault-tolerant systems. Elixir has distinctive features such as the Pipe operator, which allows developers to build a pipeline of functions as you would in the UNIX command shell. The shared byte code allows Elixir to interoperate with Erlang and leverage existing libraries while supporting tools such as the Mix build tool, the IEx interactive shell and the  ExUnit  unit-testing framework. Interest in the  Elixir  programming language continues to build. Increasingly, we see it used in serious projects and hear feedback from developers who find its Actor model to be robust and very fast. Elixir, which is built on top of the Erlang virtual machine, is showing promise for creating highly concurrent and fault-tolerant systems. Elixir has distinctive features such as the Pipe operator, which allows developers to build a pipeline of functions as you would in the UNIX command shell. The shared byte code allows Elixir to interoperate with Erlang and leverage existing libraries while supporting tools such as the Mix build tool, the IEx interactive shell and the  ExUnit  unit-testing framework. We continue to see a lot of excitement from people using the  Elixir  programming language. Elixir, which is built on top of the Erlang virtual machine, is showing promise for creating highly concurrent and fault-tolerant systems. Elixir has distinctive features such as the Pipe operator, which allows developers to build a pipeline of functions as you would in the UNIX command shell. The shared byte code allows Elixir to interoperate with Erlang and leverage existing libraries while supporting tools such as the Mix build tool, the Iex interactive shell and the ExUnit unit testing framework. Elixir is a dynamic, functional, homoiconic programming language built on top of the Erlang virtual machine with a powerful macro system that makes it ideal for building Domain Specific Languages. Elixir has distinctive features such as the Pipe operator that allows developers to build a pipeline of functions like you would in the UNIX command shell. The shared byte code allows Elixir to interoperate with Erlang and leverage existing libraries while supporting tools such as the Mix build tool, the Iex interactive shell and the ExUnit unit testing framework. It is a practical alternative to Erlang for building DSLs. 
We have been prompted to reconsider  Elm  because of the rapid adoption of  Redux  framework. Elm—the original inspiration for Redux—offers the view componentization and reactiveness of  React.js  along with the predictable state of Redux in a compiled, strongly typed functional language. Elm is written in Haskell and has a Haskell-like syntax but compiles down to HTML, CSS and JavaScript for the browser. JavaScript programmers rushing to embrace React.js and Redux might want to also consider Elm as a type-safe alternative for some applications. Elm  is a functional programming language that is used to build web based user interfaces in a functional reactive style. Elm is strongly statically typed and built on the Haskell platform. Elm has a Haskell-like syntax but compiles down to HTML, CSS and JavaScript. While still in its very early days, individuals and teams interested in exploring highly interactive web-based GUIs should look into this interesting little language. 
We&#39;ve recommended  Truffle  for  decentralized application  (dapp) development in the past.  Embark  too can make your work easier. Embark provides features such as scaffolding, building, testing and debugging and integrates with decentralized storages such as  IPFS . Through its declarative configuration, you can manage  smart contract  configuration, dependencies, artifact and deployment quite easily. Embark&#39;s interactive CLI dashboard is also impressive. We keep seeing people use  Remix  to write smart contracts and manually deploy their apps without automated testing, source control management or artifact management. We&#39;d like to draw people&#39;s attention to dapp engineering practice by promoting tools such as Truffle and Embark. 
If you are faced with building a single-page application (SPA) and trying to choose a framework to build with,  Ember.js  has emerged as a leading choice. Our teams praise Ember for its highly productive developer experience, with far fewer surprises than other frameworks such as  AngularJS . The Ember CLI build tooling is a haven in the storm of JavaScript build tools, and the Ember core team and community are highly active and responsive. If you are faced with building a single-page application (SPA) and trying to choose a framework to build with,  Ember.js  has emerged as a leading choice. Our teams praise Ember for its highly productive developer experience, with far fewer surprises than other frameworks such as  AngularJS . The Ember CLI build tooling is a haven in the storm of JavaScript build tools, and the Ember core team and community are highly active and responsive. Ember.js  has developed further support based on project experiences and is clearly a strong contender in the field of JavaScript application frameworks. Ember is praised for its developer experience, with far fewer surprises than other frameworks such as  AngularJS . The Ember CLI build tooling, convention-over-configuration approach and  ES6  support also gain positive feedback. Widespread usage of AngularJS continues on ThoughtWorks projects, although not every experience is positive. We continue to advise teams to assess whether the additional complexity of a single-page JavaScript application is necessary to meet their requirements. Â We also recommend assessing alternative frameworks, and in this radar edition we highlight  Ember.js  which is growing in popularity within ThoughtWorks. Â Ember is praised for its approach of opinionated convention over configuration, responsive core team of committers, performance, and build tooling support via Ember CLI. 
Most templating frameworks like  Mustache  or  FreeMarker  mix code with markup in a single file to implement complex, dynamic content.  Enlive  is a Clojure-based templating framework that completely separates programming language from HTML markup and employs CSS selectors to find and replace parts of the document. Enlive demonstrates the power of functional programming to implement complex behavior through a series of simple, composable functions acting on a common abstraction. Our teams working in Clojure have found it to be a very useful and straightforward tool. 
We don&#39;t always move deprecated tools to Hold in the Radar, but our teams feel strongly that  Enzyme  has been replaced for unit testing  React  UI components by  React Testing Library . Teams using Enzyme have found that its focus on testing component internals leads to brittle, unmaintainable tests. We don&#39;t always move deprecated tools to Hold in the Radar, but our teams feel strongly that  Enzyme  has been replaced for unit testing  React  UI components by  React Testing Library . Teams using Enzyme have found that its focus on testing component internals leads to brittle, unmaintainable tests. Enzyme  has become the defacto standard for unit testing  React  UI components. Unlike many other snapshot-based testing utilities, Enzyme enables you to test without doing on-device rendering, which results in faster and more granular testing. This is a contributing factor in our ability to massively reduce the amount of functional testing we find we have to do in React applications. In many of our projects itâ€™s used within a unit testing framework such as  Jest . We&#39;ve been enjoying the rapid component-level UI testing that  Enzyme  provides for  React.js  applications. Unlike many other snapshot-based testing frameworks, Enzyme allows you to test without doing on-device rendering, which results in faster and more granular testing. This is a contributing factor in our ability to massively reduce the amount of functional testing we find we have to do in React applications. Weâ€™ve been enjoying the rapid component-level UI testing that  Enzyme  provides for  React.js  applications. Unlike many other snapshot-based testing frameworks, Enzyme allows you to test without doing on-device rendering, which results in faster and more granular testing. This is a contributing factor in our ability to massively reduce the amount of functional testing we find we have to do in React applications. 
In the previous edition of the Radar we had  BERT  â€” which is a key milestone in the NLP landscape. Last year, Baidu released  ERNIE  2.0 (Enhanced Representation through kNowledge IntEgration) which outperformed BERT on seven GLUE language understanding tasks and on all nine of the Chinese NLP tasks. ERNIE, like BERT, provides unsupervised pretrained language models, which can be fine-tuned by adding output layers to create state-of-the-art models for a variety of NLP tasks. ERNIE differs from traditional pretraining methods in that it is a continual pretraining framework. Instead of training with a small number of pretraining objectives, it could constantly introduce a large variety of pretraining tasks to help the model efficiently learn language representations. We&#39;re pretty excited about the advancements in NLP and are looking forward to experimenting with ERNIE on our projects. 
Over many years, JavaScript has grown to become probably the most widely used programming language in the world. Nevertheless, the language itself has a few problems that many have attempted to address by using libraries or even by implementing their own languages that run on top of JavaScript (of which weâ€™ve mentioned both  CoffeeScript  and  ClojureScript  before).  ES6  (aka ECMAScript 6 or ECMAScript 2015), the new version of JavaScript, addresses many of the concerns of the older versions currently in use. Although browser support is scarce, support from mature transpilers like  Babel  allows you to write ES6 and have it supported in older browsers. For new projects, we strongly suggest starting with ES6 from day one. 
Through their extended use of  Kotlin , our development teams have gained experience with more frameworks designed specifically for Kotlin rather than using Java frameworks with Kotlin. Although it&#39;s been around for a while,  Exposed  has caught our attention as a lightweight object-relational mapper (ORM). Exposed has two flavors of database access: a typesafe internal DSL wrapping SQL and an implementation of the data access object (DAO) pattern. It supports features expected from a mature ORM such as handling of many-to-many references, eager loading, and support for joins across entities. We also like that the implementation works without proxies and doesn&#39;t rely on reflection, which is certainly beneficial to performance. 
Microsoftâ€™s F# continues to evolve, with the recent release of F# 3.0 beta. F# is excellent at concisely expressing business and domain logic. Developers trying to achieve explicit business logic within an application may opt to express their domain in F# with the majority of plumbing code in C#. The functional languages F#, Clojure and Scala still reside in the assess ring of the radar. Interest in functional languages continues to grow. Two characteristics of functional languages in particular are driving this interest, immutability with its implications for parallelism and functions as first class objects. While the introduction of closures to C# brings some of the latter capability, functional languages are almost synonymous with immutability. The placement of these languages within the assess ring indicates our view of their relative maturity and appropriateness. F#, based on OCaml, is fully supported within the Visual Studio toolset. F# includes support for objects and imperative constructs in addition to functional language constructs in a natural way. Scala, like F#, combines the object and functional paradigms, although the syntax of Scala is more Java-like. Clojure began as a JVM language and is now available on the .NET CLR. Clojure does allow for mutable state although it has an extensive set of immutable persistent data structures, all supporting multi-threaded applications. There are many similarities between these three languages, but at the moment we believe F# and Clojure to be better suited to most organizations for assessing than Scala. More work clearly needs to be done to validate this assertion. In the previous radar, we lumped functional languages together in a group. For this version, weâ€™ve exploded that group and started calling out the ones interesting to us. Of the current crop of functional languages, the one we like the most is Clojure: a simple, elegant implementation of Lisp on the JVM. The other two that we fi nd interesting are Scala (a re-thinking of Java in functional form) and F#, the OCaml derivative from Microsoft that now appears â€œin the boxâ€� in Visual Studio 2010. 
Fairseq  is a sequence-to-sequence modelling toolkit by Facebook AI Research that allows researchers and developers to train custom models for translation, summarization, language modeling and other NLP tasks. For users of  PyTorch , this is a good choice. It provides reference implementations of various sequence-to-sequence models; supports distributed training across multiple GPUs and machines; is very extensible; and has a bunch of pretrained models, including  RoBERTa  which is an optimization on top of  BERT . 
fastai  is an open-source Python library that simplifies training fast and accurate neural nets. It is built on top of  PyTorch  and has become a popular tool for our data scientists. fastai simplifies painful aspects of model training such as preprocessing and loading data down to a few lines of code. It&#39;s built on deep learning best practices and has out-of-the-box support for computer vision, natural language processing (NLP) and more. The founders&#39; motivation has been to create an easy-to-use library for deep learning and an improved successor to  Keras .  GCP ,  AWS  and  Azure  all have already included fastai in their machine images. The creators of fastai, acknowledging the speed and safety limitations of Python, have announced  embracing Swift  as an alternative language for deep learning. We&#39;ll be closely watching this space. 
In the case where implementation in  Node.js  is necessary, we see that  Fastify  is an option that our teams are very happy with. This web framework offers ease in handling request-response validations, support for  TypeScript  and a plugin ecosystem giving our teams an easier experience developing software. Although it&#39;s a good option in the Node.js ecosystem, we stand by our previous advice: don&#39;t fall into  Node overload  scenarios. 
Our teams are moving away from JQuery or raw XHR for remote JavaScript calls and instead are using the new  Fetch  API and the  Fetch  polyfill in particular. The semantics remain similar but have cleaner support for promises and CORS support. We are seeing this as the new de-facto approach. 
Flair  is a simple Python-based framework for NLP processing. It allows users to do standard NLP tasks such as  named entity recognition (NER) ,  part-of-speech tagging (PoS) ,  word-sense disambiguation  and classification and performs well on a range of NLP tasks. Flair presents a simple and unified interface for a variety of word and document embeddings, including  BERT , Elmo and its own Flair embeddings. It also has multilingual support. The framework itself is built on top of  PyTorch . We&#39;re using it in some of our projects and like its ease of use and powerful abstractions. 
In the crowded space of JavaScript frameworks, we want to highlight  Flight.js  as a lightweight framework to build components. Flight gets by without much magic when adding behavior to DOM nodes. Its event-driven and component-based nature promotes writing decoupled code. This makes testing individual components comparatively easy. Care must be taken, however, when components need to interact with each other.  There is little support for testing and a real danger to get into  event hell . We do like that it uses functional mixins for behavior, like composition instead of inheritance. In the crowded space of JavaScript frameworks, we want to highlight  Flight.js  as an alternative to consider. Flight is extremely lightweight and gets by without much magic when adding behavior to DOM nodes. Its event-driven and component-based nature promotes writing decoupled code. This makes testing individual components comparatively easy. Care must be taken, however, when components need to interact with each other.  There is little support for testing and a real danger to get into  event hell . We do like that it uses functional mixins for behaviour, like composition instead of inheritance. 
Flutter Driver  is an integration testing library for  Flutter  applications. With Flutter Driver you can instrument and drive the test suite on either real devices or emulators. Our teams continue to write unit and widget tests to ensure most of the business functionality in Flutter apps is implemented. However, for testing the actual user interaction, we&#39;re assessing Flutter Driver, and you should too. 
Several of our teams use  Flutter  and really like it. It&#39;s a cross-platform framework that enables you to write native mobile apps in  Dart . It benefits from Dart and can be compiled into native code and communicates with the target platform without bridge and context switching. Flutter&#39;s hot-reload feature is still impressive and provides superfast visual feedback when editing code. We&#39;re confident in recommending that you try Flutter on one of your projects. Flutter  is a cross-platform framework that enables you to write native mobile apps in  Dart . It benefits from Dart and can be compiled into native code and communicates with the target platform without bridge and context switchingâ€”something that can cause performance bottlenecks in frameworks such as  React Native  or  Weex . Flutter&#39;s hot-reload feature is impressive and provides superfast visual feedback when editing code. Currently, Flutter is still in beta, but we&#39;ll continue keeping an eye on it to see how its ecosystem matures. Flutter  is a cross-platform framework that enables you to write native mobile apps in  Dart . It benefits from Dart and can be compiled into native code and communicates with the target platform without bridge and context switching â€” something that can cause performance bottlenecks in frameworks such as  React Native  or  Weex . Flutterâ€™s hot-reload feature is impressive and provides superfast visual feedback when editing code. Currently Flutter is still in beta, but weâ€™ll continue keeping an eye on it to see how its ecosystem matures. 
Formik  is a useful higher-order component for making the surprisingly verbose and complex job of handling forms in  React  much easier. It localizes state management, assists with submission and optionally uses  Yup  to simplify data validation. 
Following many other programming languages, one of the language geeksâ€™ absolute favourites,  Haskell , is now also available on the JVM in the form of  Frege . This brings a purely functional programming language onto the platform, allowing for easy interoperability with other JVM languages and libraries. 
Functional programming continues its slow but steady ascent into developer mind share and, increasingly, code bases. New languages like Clojure, Scala, and F# offer great new features. Now libraries such as Functional Java, TotallyLazy and LambdaJ are back porting some functional language capabilities, particularly around higher-order functions and collections, into Java. We like this trend because it previews common capabilities of future languages yet allows developers to stay in their comfort zone. 
The remaining two language types included on the radar are often grouped together. While functional and concurrent languages may be adopted in similar environments, their approaches are different. Functional programming focuses on expressing code in the form of mathematical functions that avoid maintaining state across multiple invocations. While functional languages such as Haskell have been around for a number of years, new functional (themed) languages such as Scala, F# and Clojure have sparked some interest in this paradigm. Due to the way in which functional languages manage state, interest in these languages has increased by many developers seeking to make the most out of multi-core processors. Many concurrent languages are also functional languages. The distinction lies in the emphasis on running operations in parallel. A number of such languages exist; Erlang is currently the most popular of these languages. Concurrent languages commonly provide some means for handling concurrency by using messages to communicate across multiple threads. 
This language/framework was included in this edition of the Radar for visibility. We felt that there wasn&#39;t anything substantial to add to the discourse around it, but that it was important to keep this in view. This language/framework was included in this edition of the Radar for visibility. We felt that there wasn&#39;t anything substantial to add to the discourse around it, but that it was important to keep this in view. 
Gatsby.js  is a framework to write web applications in an architectural style known as  JAMstack . Part of the application is generated at build time and deployed as a static site, while the remainder of the functionality is implemented as a  progressive web application (PWA)  running in the browser. Such applications work without code running on the server side. Usually, though, the PWA makes calls to third-party APIs and SaaS solutions for content management, for example. In the case of Gatsby.js, all client and build time code is written using React. The framework includes some optimizations to make the web application feel fast. It provides code and data splitting out of the box to minimize load times and speeds up performance when navigating the application by prefetching resources. APIs are called via  GraphQL  and several plugins simplify integration with existing services. 
The  Go language  gradually changed status from &#34;Just Another Language&#34; to a valuable tool in many projects. While steadfastly single paradigm in a world of increasingly complex languages, it seems to keep a nice balance between expressiveness, power, and simplicity. The  Go language  gradually changed status from &#34;Just Another Language&#34; to a valuable tool in many projects. While steadfastly single paradigm in a world of increasingly complex languages, it seems to keep a nice balance between expressiveness, power, and simplicity. The Go language was originally developed by Google as a system programming language to replace C &amp; C++. Four years out, Go is gaining traction in other areas. The combination of very small, statically linked binaries combined with an excellent HTTP library means Go has been popular with organizations making use of finer-grained, microservice architectures. 
The ability to compile the  Go programming language  to bare metal targets has raised interest among developers in using the language for embedded systems.  Gobot  is a framework for robotics, physical computing, and the Internet of Things, written in the Go programming language and supporting a variety of platforms. We&#39;ve used the framework for experimental robotic projects where real-time response hasn&#39;t been a requirement, and weâ€™ve created open source  software drivers  with Gobot. Gobot HTTP APIs enable simple hardware integration with mobile devices to create richer applications. The ability to compile the  Go programming language  to bare metal targets has raised interest among developers in using the language for embedded systems.  Gobot  is a framework for robotics, physical computing, and the Internet of Things, written in the Go programming language and supporting a variety of platforms. We&#39;ve used the framework for experimental robotic projects where real-time response hasn&#39;t been a requirement, and weâ€™ve created open source  software drivers  with Gobot. Gobot HTTP APIs enable simple hardware integration with mobile devices to create richer applications. 
Dart is Googleâ€™s attempt at creating a programming language to replace JavaScript due to JavaScriptâ€™s perceived flaws and inherent performance issues. Dart, in line with previous Google languages, provides Java-like syntax and semantics that are intended to be more appealing than JavaScriptâ€™s prototype-based nature. Reception within the browser-development community has been understandably cool and it remains to be seen if the language will become more widely accepted, though Chromeâ€™s continued rise and the search for alternatives like CoffeeScript may yet shift that balance. 
GraphQL Inspector  lets you compare changes between two GraphQL schemas. We&#39;ve  cautioned against the use of GraphQL  in the past, and we&#39;re happy to see some improvements in tooling around GraphQL since. Most of our teams continue to use  GraphQL for server-side resource aggregation , and by integrating GraphQL Inspector in their CI pipelines, we&#39;ve been able to catch potential breaking changes in the GraphQL schema. 
We&#39;ve seen many successful  GraphQL  implementations on our projects. We&#39;ve seen some interesting patterns of use too, including  GraphQL for server-side resource aggregation . That said, we&#39;ve concerns about misuse of this framework and some of the problems that can occur. Examples include performance gotchas around N+1 queries and lots of boilerplate code needed when adding new models, leading to complexity. There are workarounds to these gotchas such as query caching. Even though it&#39;s not a silver bullet, we still think it&#39;s worth assessing as part of your architecture. When we look at REST implementations in the wild, we frequently see REST misused to naively retrieve object graphs through chatty interactions between client and server. Facebook&#39;s  GraphQL  is an interesting alternative to REST that might be a better approach for this very common use case. As a protocol for remotely retrieving object graphs, GraphQL has received enormous attention recently. One of GraphQL&#39;s most interesting features is its consumer-oriented nature: The structure of a response is driven entirely by the client, not the server. This decouples the consumer and forces the server to obey Postel&#39;s law. Client implementations are now available in many programming languages, but we have seen a flurry of interest of Facebook&#39;s  Relay , a JavaScript framework that was designed to support the  React.js  stateless component model. 
This language/framework was included in this edition of the Radar for visibility. We felt that there wasn&#39;t anything substantial to add to the discourse around it, but that it was important to keep this in view. Gremlin is an imperative graph traversal language supported by multiple graph databases. Its concise constructs can be used in place of the native language of the database, leading to faster development times and, in some cases, faster execution. We recommend its use as a good alternative in simple scenarios. 
Functional languages have a wide range of practical uses, including simulation, computational fi nance, computational science, large scale data processing and parsing. These fields benefit from functional programming techniques that simplify concurrent execution and the expression of complex mathematical functions concisely. Functional programming requires a shift in thinking for enterprise developers experienced in object oriented development. Moving to an often terse syntax for solving complex problems may initially be intimidating to many. As with all forms of programming languages, syntax is just one aspect of the language itself. In functional programming another significant aspect is the use of common idioms. These idioms speed code comprehension and increase overall maintainability. This might not be news to all, but it is worth noting that dynamic languages are long ready for adoption and trial. Ruby, particularly when deployed on JRuby, is ready for adoption. ThoughtWorks uses Ruby and JRuby extensively in both its Services and Product work. Groovy is ready for trial and could prove more accessible than Ruby/JRuby in a Java shop. For the right type of applications, Ruby, JRuby, and Groovy prove far more effective, expressive, and productive than Java and C#. 
We see lots of teams creating RESTful interfaces without paying any attention to hypermedia.  HAL  is a simple format for incorporating hyperlinks into JSON representations which is easy to implement and consume. HAL is well supported by libraries for parsing and representing JSON, and there are HAL-aware REST client libraries such as  Hyperclient  which make it easy to navigate resources by following links. We see lots of teams creating RESTful interfaces without paying any attention to hypermedia.  HAL  is a simple format for incorporating hyperlinks into JSON representations which is easy to implement and consume. HAL is well supported by libraries for parsing and representing JSON, and there are HAL-aware REST client libraries such as  Hyperclient  which make it easy to navigate resources by following links. 
HAML is a language that allows you to use indentation to lay out the structure of HTML. While not a general replacement for HTML, it is effective for focusing on the hierarchical structure of tags. 
Along with JavaScript and HTML, CSS is a core technology for creating websites. Unfortunately, the language itself lacks key features, which leads to a high level of duplication and a lack of meaningful abstractions. While CSS3 aims to rectify some of these issues, it will be years before the modules that make up CSS3 will be properly supported in most browsers. Fortunately, there is a solution today using  CSS preprocessors  like SASS and LESS. Due to their quality and support, we believe that the days of  handwritten CSS , for anything apart from trivial work, are over. 
One common problem in application development is how to schedule tasks that run outside the main process periodically or when certain conditions are met. The problem gets more complicated when unexpected events, such as application shutdowns, occur. The  Hangfire   framework, as our teams discovered, can do this and much more in the .NET environment. Hangfire is both easy to use and flexible, and it embraces a functional style. Particularly interesting is its ability to save a task&#39;s state so it can resume when an application restarts after a crash or shutdown. 
Although we&#39;re big advocates of defining  security policy as code , the tooling in this space has been fairly limited. If you&#39;re using HashiCorp products (such as  Terraform  or  Vault ) and don&#39;t mind paying for the enterprise versions, you have the option of using  HashiCorp Sentinel . Sentinel is, in effect, a complete programming language for defining and implementing context-based policy decisions. For example, in Terraform it can be used to test for policy violations before applying infrastructure changes. In Vault, Sentinel can be used to define fine-grained access control on the APIs. This approach has all the benefits of encapsulation, maintainability, readability and extensibility that high-level programming languages offer, creating an attractive alternative to traditional, declarative security policy. Sentinel is in the same class of tools as  Open Policy Agent  but is proprietary, closed-source and only works with HashiCorp products. 
While there are lots of fans of  Haskell  among ThoughtWorks&#39; language devotees, we rarely see it on the kinds of projects we work onâ€”until recently. Several open source projects now marry  Hadoop â€™s map/reduce jobs to Haskellâ€™s syntax, which some developers and/or data scientists find appealing. 
Hermes  is a JavaScript engine optimized for fast start-up of  React Native  applications on Android. JavaScript engines such as  V8  have just-in-time (JIT) compilers that profile the code at run time to produce optimized instructions. Hermes, however, takes a different approach by compiling the JavaScript code ahead of time (AOT) into an optimized bytecode. As a result you get a smaller APK image size, lean memory consumption and faster startup time. We&#39;re carefully assessing Hermes in a few React Native apps and recommend you do the same. 
Hive  is a data warehouse built on top of Hadoop which provides a SQL-like query and data definition language. Hive converts queries into MapReduce jobs that can be run across the entire Hadoop cluster. Like all useful abstractions, Hive does not try to deny the existence of the underlying mechanics of Hadoop and supports custom map-reduce operations as a powerful extension mechanism. Despite the superficial similarities to SQL, Hive does not try to be a replacement for low-latency, real-time query engines found on relational database systems. We strongly advise against using Hive for online ad-hoc querying purposes. 
HiveRunner  is an open-source unit test framework for Apache Hadoop  Hive  queries based on JUnit4. When writing nontrivial analytics or data pipelines in Hive SQL, we found HiveRunner to be a good enabler for writing tests and even TDDing out some moderately complicated SQL. HiveRunner enables you to write Hive SQL as releasable tested artifacts. 
While HTML5 is an evolving standard, many elements have reached the stage where they can be safely used in production to create both on and offline mobile web applications. Based on our projects we think HTML5 is ready to be adopted for mobile web applications. As the standard continues to evolve we expect HTML5 will become an increasingly viable alternative to native applications with the distinct advantage of being inherently cross platform. HTML 5 continues to be the preferred choice for developing complex Web-based applications, with features including improved integration of rich audio and video content, clientside storage, better document structure, Web sockets and offline use. Safari, Chrome, Firefox and Opera each support significant subsets of the proposed standards, with support coming in Internet Explorer 9. HTML 5 is likely to remain in draft for some time to come, however; early adopters may wish to reflect on the bleakly comedic saga of two separate groups attempting to drive its evolution. HTML 5 offers a large number of improvements over HTML 4 and XHTML 1.0. Many of these improvements are focused on providing support for developing complex web applications, and improving integration of rich content such as audio and video in standard ways. Features such as client-side storage, web sockets and offline use will further establish the position of the web browser as a viable enterprise application platform. This platform was included in this edition of the Radar for visibility. We felt that there wasn&#39;t anything substantial to add to the discourse around it, but that it was important to keep this in view. 
There is a tendency to equate the need for offline functionality with the need to build an app. Despite the slow standardization process, most HTML5 features have now been implemented across all major browsers. Its local storage capabilities, comprehensively supported across mobile and tablet browsers - makes HTML5 for offline applications a very suitable option. HTML5 includes features that allow control and storage of offline data within the browser using client side JavaScript. These features allows creation of offline mobile web applications in a cross platform way that would have previously required installed applications. For instance an application that can download articles for reading later or a data capture application that can work offline and upload when you are online. While the standard is not finalized yet, support for these offline features is available and ready for use in the WebKit based browsers found on iOS, Android and newer Blackberry phones. 
http4k  is an HTTP toolkit written in pure  Kotlin  for serving and consuming HTTP services. One of the key ideas behind http4k is that HTTP apps are modelled by composing two simple functions â€” HttpHandler and Filter. They derive inspiration from Twitter&#39;s  &#34;Your Server as a Function&#34;  paper. It&#39;s very lightweight with the core module having no dependencies apart from Kotlin StdLib. Apart from its elegance and simplicity, we also like its emphasis on testability â€” given that the entities in the libraries are immutable and the routes in the app, as well as the app itself, are just functions, they&#39;re super easy to test. One of the things to be aware of, though, is that we don&#39;t have nonblocking or coroutines support in http4k yet. 
Given the number of JavaScript application frameworks weâ€™ve featured in the Radar over the years we asked ourselves, do we really need to call out another one? We decided that  Hyperapp  is worth a look because of its minimalist approach. It has a very small footprint, less than 1KB, and yet covers all the essential functionality for writing a web application. This is only possible with an elegant design that reduces everything to the absolute minimum, which in turn makes it easier to understand and use the framework. Despite being relatively new, it has attracted a good-size community and we recommend to at least consider it when picking a framework for a new application. 
The  Hyperledger  project has grown into a broader collaboration and now contains a series of subprojects. It supports Blockchain implementations for different purposes; for example,  Burrow  is dedicated to build a permissioned  Ethereum  and  Indy  is more focused on digital identity. Among these platforms,  Fabric  is the most mature one. Most of time when people talk about adopting Hyperledger they are actually thinking about Hyperledger Fabric. However, the programming abstraction of  chaincode  is relatively low level given it manipulates the state of the ledger directly. Moreover, it always takes a lot of time to set up infrastructure before writing the first line of blockchain code.  Hyperledger Composer , which builds on top of Fabric, accelerates the process of turning ideas into software. Composer provides DSLs to model business assets, define access control and build a business network. By using Composer you could quickly validate your idea through a browser without setting up any infrastructure. Just remember that the Composer itself isn&#39;t Blockchain â€” you still need to deploy it on Fabric. 
HyperResource  is a Ruby framework for building a RESTful API client. The framework accepts JSON in  HAL  format and dynamically generates a model object complete with hypermedia links. Although the framework is still in its infancy, we like that it embraces  Richardson level 3 REST  for better service discoverability and self-documenting protocols. 
With the increasing complexity of single-page JavaScript applications, managing state predictably is becoming more and more important. Immutability can help to ensure our applications behave consistently but unfortunately JavaScript doesn&#39;t offer built-in deeply immutable data structures (see the  ES Record and Tuple proposal ).  Immer  â€” German for  always  â€” is a tiny package that lets you work with immutable state in a more convenient way. It&#39;s based on the copy-on-write mechanism, has a minimal API and operates on normal JavaScript objects and arrays. This means that data access is seamless and no large refactoring efforts are needed when introducing immutability to an existing codebase. Many of our teams now use it in their JavaScript codebases and prefer it to  Immutable.js , which is why we&#39;re moving it to Trial. With the increasing complexity of single-page JavaScript applications, managing state predictably is becoming more and more important. Immutability can help to ensure our applications behave consistently, but unfortunately JavaScript doesn&#39;t natively support the ability to create immutable objects. Libraries such as  Immutable.js  filled that gap but introduced new problems because now two kinds of objects and arrays existed in the application, the library&#39;s version and the native JavaScript ones.  Immer  â€” German for  always  â€” is a tiny package that lets you work with immutable state in a more convenient way. It&#39;s based on the copy-on-write mechanism, has a minimal API and operates on normal JavaScript objects and arrays. This means that data access is seamless and no large refactoring efforts are needed when introducing immutability to an existing codebase. 
Immutability is often emphasized in the functional programming paradigm, and most languages have the ability to create immutable objectsâ€”objects that can&#39;t be changed once created.  Immutable.js  is a library for JavaScript that provides many persistent immutable data structures, which are highly efficient on modern JavaScript virtual machines. Immutable.js objects are, however, not normal JavaScript objects, so references to JavaScript objects from immutable objects should be avoided. More teams are using this library for tracking mutation and maintaining state in production. We recommend that developers investigate this library, especially when it&#39;s combined with the rest of the Facebook stack. Immutability is often emphasized in the functional programming paradigm, and most languages have the ability to create immutable objects, which cannot be changed once created.  Immutable.js  is a library for JavaScript that provides many persistent immutable data structures, which are highly efficient on modern JavaScript virtual machines. Immutable.js objects are, however, not normal JavaScript objects, so references to JavaScript objects from immutable objects should be avoided. Our teams have had value using this library for tracking mutation and maintaining state, and it is a library we encourage developers to investigate, especially when it&#39;s combined with the rest of the Facebook stack. 
Instana  is yet another entrant into the crowded application performance management space. The fact that it&#39;s built from the ground up for cloud native architectures differentiates Instana from many of its competitors. Features include dynamic discovery, distributed tracing and service health plus the ability to &#34;time shift&#34; your view of your infrastructure to the moment an incident occurred. It remains to be seen whether this product can gain traction over the combination of open source projectsâ€”such as  Consul ,  Prometheus  and the implementations of  OpenTracing â€”that do the same thing; however it&#39;s worth taking a look if you need an out-of-the-box solution. Instana  is yet another entrant into the crowded application performance management space. The fact that it&#39;s built from the ground up for cloud native architectures differentiates Instana from many of its competitors. Features include dynamic discovery, distributed tracing and service health plus the ability to &#34;time shift&#34; your view of your infrastructure to the moment an incident occurred. It remains to be seen whether this product can gain traction over the combination of open source projectsâ€”such as  Consul ,  Prometheus  and the implementations of  OpenTracing â€”that do the same thing; however it&#39;s worth taking a look if you need an out-of-the-box solution. 
We&#39;ve been really enjoying using  TypeScript  for a while now and love the safety that the strong typing provides. However, getting data into the bounds of the type system, from say a call to a back-end service, can lead to run-time errors. One library that helps solve this problem is  io-ts . It bridges the gap between compile-time type-checking and run-time consumption of external data by providing encode and decode functions. It can also be used as a custom type guard. According to our teams, it&#39;s an elegant solution to a rascal of a problem. 
Ionic framework  is an open-source front-end framework that offers a library of mobile-optimized HTML, CSS and JavaScript components and tools for building highly interactive applications. It is built with SASS and optimized for AngularJS. We have seen success in several of our projects employing this framework, with its ease to install and test. We recommend investigating this framework when you are performance obsessed and looking for a seamlessly integrated front-end framework. 
We have long thought of JavaScript as a first class language, and have been keenly following the development of testing tools in that space. The cream of the crop for out-of-browser testing is currently Jasmine. Jasmine paired with Node.js is the go-to choice for robust testing of both client- and serverside JavaScript. 
The team behind  Java 8  had to fight two battles: the community forces encouraging forever backwards compatibility (a long hallmark of Java) and the technical challenge of making a deep language change mesh with existing libraries and features. They succeeded on both fronts, breathing new life into the Java Language and placing it on par with other mainstream languages in terms of functional programming features. In particular, Java 8 has excellent syntactic magic that allows seamless interoperability between Lambda blocks, the new higher-order function feature, and SAM (Single Abstract Method) interfaces, the traditional way of passing behavior. The team behind  Java 8  had to fight two battles: the community forces encouraging forever backwards compatibility (a long hallmark of Java) and the technical challenge of making a deep language change mesh with existing libraries and features. They succeeded on both fronts, breathing new life into the Java Language and placing it on par with other mainstream languages in terms of functional programming features. In particular, Java 8 has excellent syntactic magic that allows seamless interoperability between Lambda blocks, the new higher-order function feature, and SAM (Single Abstract Method) interfaces, the traditional way of passing behavior. 
The purchase of Sun, and thus their Java assets, by Oracle introduced uncertainty regarding the future of Java. This uncertainty continues despite the recent announcements of Oracleâ€™s Java roadmap, which had both encouraging and worrying aspects. As a result we continue to highlight the issue. We recommend monitoring the situation rather than any immediate actions to move off the platform. As we have discussed previously, the Java language appears to be moving slowly as the Java community waits for Java 7. Having waited for new language features to surface for almost 3 years, the Java community has begun to innovate in new languages that run on the Java Virtual Machine, languages such as Groovy, JRuby, Scala and Clojure. With the increase in number of languages available on the JVM, we expect enterprises to begin to assess the suitability of reducing the amount of Java specific code developed in their enterprise applications in favor of these newer languages. This is not to say that enterprises should outright abandon Java as a programming language, we do however suggest that you look for alternatives that may be more fi t for purpose in the area that new development is taking place. As C# continues to surge ahead, the Java language appears to be moving slowly as the Java community waits for Java 7. Having waited for new language features to surface for almost 3 years, the Java community has begun to innovate in new languages that run on the Java Virtual Machine, languages such as Groovy, JRuby, Scala and Clojure. With the increase in number of languages available on the JVM, we expect enterprises to begin to assess the suitability of reducing the amount of Java specific code developed in their enterprise applications in favor of these newer languages. 
Rich experiences delivered via the web to desktops, tablets and mobile devices rely heavily on JavaScript, and we continue to recommend treating JavaScript as a â€œfirst classâ€� language within your application. Developers should carefully consider how they structure, test, refactor and maintain JavaScript code, applying the same rigor as they would with any other programming language. The maintainability, testability and readability of JavaScript is a very significant contributor to the productivity of teams producing Web-based applications and sites. ThoughtWorks believes JavaScript deserves to be treated as a first class language, viewing it as second class citizen has become an excuse for a whole series of bad practice we would not tolerate in Java or C#. We need to use the same kind of tools (e.g. unit testing) and approaches (e.g. refactoring) as weâ€™d use for any other production language. V8 and other JavaScript engines are raising the bar on performance, while Flash &amp; Silverlight seem to be losing momentum to HTML5 + JavaScript in areas where a rich client-like experience is required. This is good news for all interested in open standards on the Web. 
JavaScript is moving outside of the browser, emerging as an important technology for cross-platform development. It is front-and-center in the approach to code reuse taken by Node.js, Meteor.js and mobile frameworks like Calatrava. Along with the recent proliferation of other languages that compile to JavaScript, this makes us wonder if we should start to consider JavaScript as a platform and not just a language. 
Single-page web application development continues to flourish along with the frameworks supporting data binding, client-side templates, validation, and other capabilities. The JavaScript MV* frameworks in active use on ThoughtWorks projects include AngularJS, Knockout, and Ember.js. Each has advocates and a few detractors. We expect continuing innovative churn in this vibrant space. 
With the increased adoption of a  microservices  architecture, we&#39;re building more distributed applications than before. Although there are many benefits of a decoupled architecture, the complexity and the effort involved in proving the correctness of the overall system has dramatically increased.  Jepsen  provides much needed tooling to verify correctness in coordination of task schedulers, test eventual consistency,  linearizability  and  serializability  characteristics of distributed databases. We&#39;ve used Jepsen in a few projects and we like the fact that we can test drive configurations, inject and correct faults, and verify the state of the system after recovery. With the growth in usage of NoSQL data stores, and the growth in popularity of polyglot approaches to persistence, teams now have many choices when it comes to storing their data. While this has brought many advantages, product behavior with flaky networks can introduce subtle (and not so subtle) issues that are often not well understood, even in some cases by the product developers themselves. The  Jepsen  toolkit and accompanying  blog  have become the de-facto reference for anyone looking to understand how different database and queuing technologies react under adverse conditions. Crucially, the approach to testing, which includes clients in the transactions, shines a spotlight on possible failure modes for many teams building microservices. 
jest-when  is a lightweight JavaScript library that complements  Jest  by matching mock function call arguments. Jest is a great tool for testing the stack; jest-when allows you to expect specific arguments for mock functions which enables you to write more robust unit tests of modules with many dependencies. It&#39;s easy to use and provides great support for multiple matchers, which is why our teams have made jest-when their default choice for mocking in this space. jest-when  is a lightweight JavaScript library that complements  Jest  by matching mock function call arguments. Jest is a great tool for testing the stack; jest-when allows you to expect specific arguments for mock functions and thus lets you write more robust unit tests of modules with many dependencies. 
Our teams are delighted with the results of using  Jest  for front-end testing. It provides a â€˜zero-configurationâ€™ experience and has out-of-the-box features such as mocking and code coverage. You can apply this testing framework not only to  React  applications, but also to other JavaScript frameworks. One of Jest&#39;s often hyped features is UI snapshot testing. Snapshot testing would be a good addition to the upper layer of the  test pyramid , but remember, unit testing is still the solid foundation. 
joi  is a schema description language and validator for JavaScript objects. We like that joi is independent of any web application framework, so our teams can use the same schemas across different stacks. You can also use companion libraries to generate Swagger documentation for APIs that validate requests with joi schemas. 
We continue to see teams run into trouble using  JSF  - JavaServer Faces - and are recommending you avoid this technology. Teams seem to choose JSF because it is a Java EE standard without really evaluating whether the programming model suits them. We think JSF is flawed because its programming model encourages use of its own abstractions rather than fully embracing the underlying web model. JSF, like ASP.NET webforms, attempts to create stateful component trees on top HTML markup and the stateless HTTP protocol. The improvements in JSF 2.0 and 2.2, such as the introduction of stateless views and the promotion of GET, are steps in the right direction, maybe even an acknowledgement that the original model was flawed, but we feel this is a too little too late. Rather than dealing with the complexity of JSF we recommend teams use simple frameworks and work closely with web technologies including HTTP, HTML and CSS. We continue to see teams run into trouble using  JSF  - JavaServer Faces - and are recommending you avoid this technology. Teams seem to choose JSF because it is a Java EE standard without really evaluating whether the programming model suits them. We think JSF is flawed because its programming model encourages use of its own abstractions rather than fully embracing the underlying web model. JSF, like ASP.NET webforms, attempts to create stateful component trees on top HTML markup and the stateless HTTP protocol. The improvements in JSF 2.0 and 2.2, such as the introduction of stateless views and the promotion of GET, are steps in the right direction, maybe even an acknowledgement that the original model was flawed, but we feel this is a too little too late. Rather than dealing with the complexity of JSF we recommend teams use simple frameworks and work closely with web technologies including HTTP, HTML and CSS. 
Many iOS developers are using  JSPatch  to dynamically patch their apps. When a JSPatch-enabled app runs, it loads a chunk of JavaScript (potentially via an insecure HTTP connection) and then bridges to the main Objective-C application code to change behavior, fix bugs, and so on. While convenient, we think monkey-patching live apps is a bad idea and should be avoided. When doing any amount of incremental patching, it&#39;s very important that your testing process matches what end users will experience, in order to properly validate functionality. An alternative approach is to use  React Native  for the app and  AppHub  and  CodePush  to push small updates and new features. 
Julia  is a dynamic, procedural and homoiconic programming language designed to address the needs of high performance scientific computing. The implementation of the language is organized around the concept of generic functions and dynamic method dispatch. Julia programs are largely functions that can contain multiple definitions for different combinations of argument types. The combination of these language features and the LLVM based just-in-time compiler help Julia achieve a high level of performance. Julia also supports a multiprocessing environment based on message passing to allow programs to run on multiple processes. This enables programmers to create distributed programs based on any of the models for parallel programming. 
JuMP  is a domain-specific language for  mathematical optimizations  in  Julia . JuMP defines a common API called  MathProgBase  and enables users to write solver-agnostic code in Julia. Currently supported solvers include  Artelys Knitro ,  Bonmin ,  Cbc ,  Clp ,  Couenne ,  CPLEX ,  ECOS ,  FICO Xpress ,  GLPK ,  Gurobi ,  Ipopt ,  MOSEK ,  NLopt  and  SCS . One other benefit is the implementation of automatic differentiation technique in reverse mode to compute derivatives so users are not limited to the standard operators like sin, cos, log and sqrt but can also implement their own custom objective functions in Julia. JuMP  is a domain-specific language for  mathematical optimizations  in  Julia . JuMP defines a common API called  MathProgBase  and enables users to write solver-agnostic code in Julia. Currently supported solvers include  Artelys Knitro ,  Bonmin ,  Cbc ,  Clp ,  Couenne ,  CPLEX ,  ECOS ,  FICO Xpress ,  GLPK ,  Gurobi ,  Ipopt ,  MOSEK ,  NLopt  and  SCS . One other benefit is the implementation of automatic differentiation technique in reverse mode to compute derivatives so users are not limited to the standard operators like sin, cos, log and sqrt but can also implement their own custom objective functions in Julia. 
Given our experience that tests are the only API specifications that really matter, we&#39;re always on the lookout for new tools that might help with testing.  Karate  is an API testing framework whose unique feature is that tests are written in Gherkin-based syntax without relying on a general-purpose programming language to implement test behavior. Karate uses a domain-specific language for describing HTTP-based API tests. Our teams like the readable specification that they get with this tool and recommend to keep tests with Karate in the upper levels of the  testing pyramid  and not overload its use by making very detailed assertions. Given our experience that tests are the only API specifications that really matter, we&#39;re always on the lookout for new tools that might help.  Karate  is an API testing framework whose unique feature is that tests are written directly in Gherkin without relying on a general-purpose programming language to implement test behavior. Karate is really a domain-specific language for describing HTTP-based API tests. Although this approach is interesting and makes for some very readable specifications for simple tests, the special-purpose language for matching and validating payloads can become quite syntax-heavy and difficult to understand. It remains to be seen if more complex tests written in this style will be readable and maintainable over the long haul. 
In the past we&#39;ve talked about the  improving   tooling  for applying  good engineering practices  in data science projects.  Kedro  is another good addition in this space. It&#39;s a development workflow framework for data science projects that brings a standardized approach to building production-ready data and machine-learning pipelines. We like the focus on software engineering practices and good design with its emphasis on test-driven development, modularity, versioning and good hygiene practices such as keeping credentials out of the codebase. 
Keras  is a high-level interface in Python for building neural networks. Created by a Google engineer, Keras is open source and runs on top of either  TensorFlow  or  Theano . It provides an amazingly simple interface for creating powerful deep-learning algorithms to train on CPUs or GPUs. Keras is well designed with modularity, simplicity, and extensibility in mind. Unlike a library such as  Caffe , Keras supports more general network architectures such as recurrent nets, making it overall more useful for text analysis, NLP and general machine learning. If computer vision, or any other specialized branch of machine learning, is your primary concern, Caffe may be a more appropriate choice. However, if youâ€™re looking to learn a simple yet powerful framework, Keras should be your first choice. Keras  is a high-level interface in Python for building neural networks. Created by a Google engineer, Keras is open source and runs on top of either  TensorFlow  or  Theano . It provides an amazingly simple interface for creating powerful deep-learning algorithms to train on CPUs or GPUs. Keras is well designed with modularity, simplicity, and extensibility in mind. Unlike a library such as  Caffe , Keras supports more general network architectures such as recurrent nets, making it overall more useful for text analysis, NLP and general machine learning. If computer vision, or any other specialized branch of machine learning, is your primary concern, Caffe may be a more appropriate choice. However, if you&#39;re looking to learn a simple yet powerful framework, Keras should be your first choice. 
Knet.jl  is the  KoÃ§ University  deep-learning framework implemented in  Julia  by  Deniz Yuret  and collaborators. Unlike gradient-generating compilers such as  Theano  and  TensorFlow  which force users into a restricted mini-language, Knet allows the definition and training of machine-learning models using the full power and expressiveness of Julia. Knet uses dynamic computational graphs generated at runtime for the automatic differentiation of almost any Julia code. We really like the support of GPU operations through the KnetArray type, and in case you don&#39;t have access to a GPU machine, the team behind Knet also maintains a  preconfigured Amazon Machine Image (AMI)  so you can evaluate it in the cloud. 
As  Kotlin  is used increasingly for both mobile and server-side development, the associated ecosystem continues to evolve.  Koin  is a Kotlin framework that handles one of the routine problems in software development: dependency injection. Although you can choose from a variety of dependency injection frameworks for Kotlin, our teams have come to prefer the simplicity of Koin. Koin avoids using annotations and injects either through constructors or by mimicking Kotlin&#39;s lazy initialization so that objects are injected only when needed. This is in contrast to the statically compiled  Dagger  injection framework for Android. Our developers like the lightweight nature of this framework and its built-in testability. 
Kotlin  has experienced an  accelerated rate of adoption  and rapid growth of tooling support. Some of the reasons behind its popularity are its concise syntax, null safety, ease of transition from Java and interoperability with other JVM-based languages in general, and that it doubles as a great introductory language to functional programming. With JetBrains adding the ability to compile Kotlin to  native binaries  on multiple platforms, as well as  transpile to JavaScript , we believe it has the potential of much wider use by the larger community of mobile and native application developers. Although at the time of writing, some of the tooling such as static and coverage code analysis have yet to mature, given our experience of using Kotlin in many production applications, we believe Kotlin is ready for general adoption. The announcement of first-class Android support has given an extra boost to the rapidly progressing  Kotlin  language, and we&#39;re closely following the progress of  Kotlin/Native  â€” the LLVM-backed ability to compile to native executables. Null safety, data classes and the ease of creating DSLs are some of the benefits we&#39;ve enjoyed, along with the  Anko  library for Android development. Despite the downsides of slow initial compilation and reliance on IntelliJ for first-class IDE support, we recommend giving this fresh and concise modern language a try. The  Kotlin  programming language is on many of our developers&#39; bucket lists to assess this year, and some have already used it successfully in production. It is an open source JVM language from JetBrains. Our Swift mobile developers like it as it is syntactically closer to  Swift  and equally concise. Our Java developers have enjoyed its seamless interoperability with the Java language and tools and found it easier to learn than Scala. Kotlin supports functional programming concepts but with less features than Scala. Developers on our teams who like static typing with the compiler catching null pointer defects found themselves writing fewer boilerplate tests. 
KotlinTest  is a stand-alone testing tool for the  Kotlin  ecosystem that our teams have come to like. It allows  property-based testing , a technique we&#39;ve highlighted in the Radar before. Key advantages are that it offers a variety of testing styles in order to structure the test suites and that it comes with a comprehensive set of matchers, which allow for expressive tests in an elegant internal DSL. 
Kotlin  has demonstrated its value beyond mobile app development. When building microservices and shipping software to production, our teams have had good experiences with Ktor.  Ktor  is a framework that, unlike other web frameworks that support Kotlin, is written in Kotlin, using language features such as  coroutines  which allow for an asynchronous nonblocking implementation. The flexibility to incorporate different tools for logging, DI or a template engine â€” in addition to its lightweight architecture â€” makes Ktor an interesting option for creating RESTful services. Kotlin  is no longer just a great fit for mobile app development. New tools and frameworks have emerged that demonstrate the value of the language for web application development as well.  Ktor  is one such framework. In contrast to other web frameworks that support Kotlin, Ktor is written in Kotlin, using language features such as  coroutines  which allows for an asynchronous non-blocking implementation. The flexibility to incorporate different tools for logging, DI or a templates engineâ€”in addition to its lightweight architectureâ€”makes Ktor an interesting option for our teams for creating RESTful services. 
Laconia  is a framework for developing  AWS Lambda  functions in JavaScript. As interest and use of serverless tech has grown so has the complexity of the applications being built. Laconia is a small, lightweight framework that takes away some of the rough edges we often encounter. It uses dependency injection to isolate your application code from lower-level AWS APIs and provides adaptors for the different events that your application can respond too. It also plays nicely with the  Serverless Framework  at deploy time. We like small and simple frameworks and Laconia is just that. 
Our mobile teams have been excited about  LeakCanary , a tool for detecting annoying memory leaks in Android and Java. It&#39;s simple to hook up and provides notifications with a clear trace-back to the cause of the leak. Adding this to your toolkit can save tedious hours troubleshooting out-of-memory errors on multiple devices. 
Steady progress has been made since we first wrote about  web components  in 2014.  LitElement , part of the  Polymer Project , is a simple library that you can use to create lightweight web components. It&#39;s really just a base class that removes the need for a lot of the common boilerplate making writing web components a lot easier. We&#39;ve had early success using it on projects and are excited to see the technology maturing. 
It is startling to us that we continue to find new systems in 2011 that implement significant business logic in stored procedures. Programming languages commonly used to implement stored procedures lack expressiveness, are difficult to test, and discourage clean modular design. You should only consider stored procedures executing within the database engine in exceptional circumstances, where there is a proven performance issue. 
We donâ€™t know who named  Lotus , but we can only assume they are too young to have worked with a certain office collaboration product. Lotus is a new Rack-based MVC framework written in Ruby that can be deployed modularly so that you are free to use only the portions of the framework you need.  It is a modern alternative to the monolithic Ruby-on-Rails framework (that turned 10 this year).  Lotus has the potential to make full-stack Ruby MVC development as easy as 1-2-3. 
An unlikely contender in the programming languages space, Lua has seen massive adoption across a variety of industries. It is used as a scripting platform in game development and music composition; embedded in point-of-sale appliances and network devices; and in extending NoSQL databases with safe execution semantics. We expect further growth in time to come. 
Material UI  provides reusable components for use in  React  applications that implement Google&#39;s Material Design language. Filling a similar space to  Twitter Bootstrap , it gets you up and running quickly but doesn&#39;t have the same drawbacks as your application grows.  Elemental UI  is worth investigating as an alternative. 
MediaPipe  is a framework for building MultiModal (such as video, audio, time series data, etc.), cross-platform (for example, Android, iOS, Web, and edge devices) and applied ML pipelines. It provides multiple capabilities, including face detection, hand tracking, gesture detection and object detection. Although MediaPipe is primarily deployed to mobile devices, it&#39;s started to show up in the browser thanks to WebAssembly and XNNPack ML Inference Library. We&#39;re exploring MediaPipe for some AR use cases and like what we see so far. 
Micronaut  is a JVM framework for building services using Java,  Kotlin  or Groovy. It distinguishes itself through a small memory footprint and short startup time; it achieves these improvements by avoiding runtime reflection for  dependency injection (DI)  and proxy generation, a common shortcoming of traditional frameworks, and instead uses a DI/ AOP  container which performs dependency injection at compile time. This makes it attractive not just for standard server-side microservices but also in the context of, for example, the Internet of Things, Android applications and serverless functions. Micronaut uses Netty and has first-class support for reactive programming. It also includes features such as service discovery and circuit breaking that make it cloud-native friendly. Micronaut is a very promising entrant to the full-stack framework for the JVM space, and we&#39;re seeing it in more and more projects in production, prompting us to move it to Trial. Micronaut  is a new JVM framework for building microservices using Java,  Kotlin  or Groovy. It distinguishes itself through a small memory footprint and short startup time. It achieves these improvements by avoiding runtime reflection for DI and proxy generation, a common shortcoming of traditional frameworks, and instead uses a  DI / AOP  container which performs dependency injection at compile time. This makes it attractive not just for standard server-side microservices but also in the context of, for example, the Internet of Things, Android applications and serverless functions. Micronaut uses Netty and has first-class support for reactive programming. It also includes many features that make it cloud-native friendly such as service discovery and circuit breaking. Micronaut is a very promising entrant to the full stack framework for the JVM space and we&#39;re keenly watching it. 
An open source framework developed by  WeChat ,  MMKV  provides fast key-value storage for mobile apps. It uses iOS memory-mapping features to avoid the need to explicitly save changes and is extremely fast and performant. In the event of an unexpected crash, MMKV allows the app to restore the data quickly. 
Web applications, especially those written for internal use in enterprises, are usually written in two parts. The user interface and some business logic run in the web browser while business logic, authorization and persistence run on a server. These two halves normally communicate via JSON over HTTP. The endpoints shouldn&#39;t be mistaken for a real API; they&#39;re simply an implementation detail of an application that is split across two run-time environments. At the same time, they provide a valid seam to test the pieces individually. When testing the JavaScript part, the server side can be stubbed and mocked at the network level by a tool such as  Mountebank . An alternative approach is to intercept the requests in the browser. We like the approach taken by  Mock Service Worker  because with service workers it uses an abstraction familiar to developers. This approach results in a simpler setup and faster test execution. However, because these tests don&#39;t test the actual network layer, you want to implement some end-to-end tests as part of a healthy test pyramid. 
MockK  is our go-to tool for mocks when writing tests for  Kotlin  applications. We like to use this library because of its first-class support for Kotlin language features such as  coroutines  or lambda blocks. As a native library, it helps our teams to write clean and concise code on testing Kotlin applications instead of using the inconvenient wrappers of Mockito or PowerMock. MockK  is a library for mocking written in  Kotlin . Its main philosophy is to provide first-class support for Kotlin language features such as  Coroutines  or lambda blocks. As a native library, it helps our teams to write clean and concise code on testing Kotlin applications instead of using incommodious wrappers of Mockito or PowerMock. 
One insight we gained after talking with our teams is that  Python  is making a comeback across many technology domains. In fact, it&#39;s well on its way to become the  most-used programming language . In part, this is driven by its adoption by data scientists and in machine learning, but we also see teams adopting it to build microservices.  Nameko  is a super-lightweight microservices framework and an alternative to  Flask  for writing services. Unlike Flask, Nameko only has a limited set of features that includes WebSocket, HTTP and AMQP support. We also like its focus on testability. If you don&#39;t need features such as templating that Flask provides, then Nameko is worth a look. 
Since we last talked about   Nancy    on the technology radar it has become the default choice on our .NET projects. Architectures centred around small, vertical slices and microservices simply require light-weight deployment options and low ceremony tooling. Nancy  continues to gain traction in the Alt.NET community and we have found it particularly useful for deploying low-ceremony, lightweight fakes for testing in a microservices environment. Nancy is a lightweight, open-source web framework for .NET.  In the spirit of Sinatra for Ruby, Nancy provides just the essentials necessary to implement web applications with minimal extraneous code.  Because the framework is independent of any particular hosting environment, the developer is freed from the IIS and ASP.NET environment.  This makes Nancy an excellent complement to OWIN and compatible with other OWIN modules.  We are really happy to see the emergence of lightweight web frameworks in a number of other languages as well; Spark for Java, Flask for Python, etc.. 
Nashorn  is a new JavaScript engine for Java that has been released with Java 8. When the exact same code should be run in the web browser and on the server, which is often the case for validation and data migration logic, it is the tool of choice in the Java world, and that is the case despite some rough edges. We are not convinced that using Nashorn to host entire applications, via Node support or the Avatar project, is a good idea. 
The growth in popularity of Node.js and trends such as  Node overload  have led to the application of Node.js for developing business applications. We often see problems, such as scalability and maintainability, with large JavaScript-based applications.  NestJS  is a  TypeScript-first  framework that makes the development of Node.js applications safer and less error prone. NestJS is opinionated and comes with SOLID principles and an Angular-inspired architecture out of the box. When building Node.js microservices, NestJS is one of the frameworks that our teams commonly use to empower developers to create testable, scalable, loosely coupled and easily maintainable applications. NestJS  is a server-side Node.js framework written in  TypeScript . By integrating the rich ecology of the Node.js community, NestJS provides an out-of-the-box application architecture. The mental model to develop NestJS is similar to the server-side version of Angular or the TypeScript version of Spring Boot, so the learning curve for developers is low. NestJS supports protocols such as  GraphQL , Websocket and ORM libraries. 
React.js  has revolutionized the way most people write single-page JavaScript applications. Generally, we recommend you use Create React App throughout the application lifecycle so you don&#39;t have to configure your setup, builds and packages manually. But some developers will prefer a tool whose initial defaults reflect a sound set of opinions.  Next.js  is just such an opinionated framework and it is garnering quite a bit of interest among our front-end enthusiasts. Next.js simplifies routing, renders on the server side by default and streamlines dependencies and builds. We&#39;re keen to see if it lives up to expectations on our own projects. 
Nightwatch  is a framework that allows automated acceptance tests for browser-based apps to be created in JavaScript and run in  Node.js . Nightwatch allows tests to be defined using a fluent API which can then be executed against a Selenium/WebDriver server. In the case of single page apps or other JavaScript-heavy pages, this allows the automated tests to be created and run within the same language and environment as the bulk of the code. 
OkHttp   is a Java HTTP connection library from Square that provides a fluent interface for creating connections, as well as support for the faster HTTP/2 protocol. Even when using HTTP/1.1, OkHttp can provide performance improvements via connection pooling and transparent gzip compression. Supporting both blocking synchronous and nonblocking asynchronous calls, it can also be used as a drop-in replacement for the widely used Apache HttpClient. 
We have seen continued interest in  Om , a ClojureScript wrapper around Facebook&#39;s ReactJS front-end programming framework. Om leverages the inherent immutability of ClojureScript, allowing automatic features like snapshots of UI state and undo. And due to the efficiency of ClojureScript&#39;s data structures, some Om applications run faster than identical ones based on the raw underlying React framework.  The ecosystem of components and applications around Om is growing and our teams are starting to pick it up. Adopting the entire Clojure stack (the Clojure and ClojureScript languages, and optionally the Datomic database) offers some advantages like immutable data structures from user interface to backend. Several frameworks have appeared in the Clojure space to leverage its unique features, but the most promising so far is  Om . Om is a ClojureScript wrapper around Facebook&#39;s React JavaScript reactive programming framework. Yet Om leverages the inherent immutability of ClojureScript, allowing automatic features like snapshots of UI state and undo. And due to the efficiency of ClojureScript&#39;s data structures, some Om applications run faster than identical ones based on the raw underlying React framework. We expect significant evolution and innovation to continue around Om. 
Security is the cornerstone of the blockchain economy. In the last issue of the Radar, we highlighted the importance of testing and auditing smart contracts dependencies.  OpenZeppelin  is a framework to help build secure smart contracts in  Solidity . The team behind OpenZeppelin summed up a series of  pitfalls and best practices  around smart contracts&#39; security and embedded these experiences into the source code. The framework is well reviewed and validated by the open source community. We recommend the use of OpenZeppelin instead of writing your own implementation of the  ERC20 / ERC721  token. OpenZeppelin is also integrated with  Truffle . 
One thing that has slowed the evolution of a rich, open source web development ecosystem on the .NET platform has been over-dependence on IIS and the ASP.NET framework.  OWIN specifies an open HTTP handling interface that decouples web server from application much like Rack has done for the Ruby community.  We are excited about OWIN because it opens up the possibility of new .NET web development tools composed of simple, independently-developed modules.  Nancy is the perfect example of this.  We also hope it will increase the practice of deploying web applications as standalone, self-hosted services on the .NET platform. 
When using HTML and related technologies to produce books and other print output, the question of pagination must be considered. This includes page counters, repeated elements in headers and footers, as well as mechanisms to avoid awkward page breaks.  Paged.js  is an open-source library that implements a series of polyfills for the  Paged Media  and  Generated Content for Paged Media  CSS modules. It is still experimental but fills an important gap in the &#34;write once, publish everywhere&#34; story for HTML. 
PowerShell remains a widely used option for doing low-level automation on Windows machines.  Pester  is a testing library that makes it possible to execute and validate PowerShell commands. Pester simplifies testing of scripts during development with a powerful mocking system that makes it possible to setup stubs and doubles in tests. Pester tests can also be integrated into a continuous integration system to prevent regression defects. 
Some of our ThoughtWorks teams have had very positive experiences with  Phoenix , a server-side web MVC framework written in  Elixir . In addition to being streamlined and easy to use, Phoenix takes advantage of Elixir to be extremely fast. For some developers, Phoenix evokes the joy they experienced when first discovering Ruby and Rails. Although the ecosystem of libraries for Phoenix is not as extensive as for some more mature frameworks, it should benefit from the continuing success and growth of support for Elixir. Some of our ThoughtWorks teams have had very positive experiences with  Phoenix , a server-side web MVC framework written in  Elixir . In addition to being streamlined and easy to use, Phoenix takes advantage of Elixir to be extremely fast. For some developers, Phoenix evokes the joy they experienced when first discovering Ruby and Rails. Although the ecosystem of libraries for Phoenix is not as extensive as for some more mature frameworks, it should benefit from the continuing success and growth of support for Elixir. 
We have been intrigued by the  Physical Web  standard created by Google. The idea of Physical Web is simpleâ€”beacons broadcast a URLâ€”but the possibilities are broad. Basically, this is a way to annotate the physical world, tying objects and locations into the digital realm. The current transport mechanism is  Eddystone URLs  over Bluetooth LE, and sample clients are available. Although there are obvious security concerns with following randomly discovered links, we are most interested in use cases with customized clients where you can filter or proxy the URLs as required. We have been intrigued by the  Physical Web  standard created by Google. The idea of Physical Web is simpleâ€”beacons broadcast a URLâ€”but the possibilities are broad. Basically, this is a way to annotate the physical world, tying objects and locations into the digital realm. The current transport mechanism is  Eddystone URLs  over Bluetooth LE, and sample clients are available. Although there are obvious security concerns with following randomly discovered links, we are most interested in use cases with customized clients where you can filter or proxy the URLs as required. 
The  Play Framework 2  blip has generated many internal discussions. We had competing suggestions to move it to adopt and hold. These differences relate primarily to the specific applications for which it is used, how it is used, and what expectations people have for it. While none of these issues are unique for Play, Play has generated far more controversy than is typical in the standard library versus framework debate. We reiterate the cautions stated in the previous radar, and we will monitor how Play continues to mature to support its sweet spot. The recent release of Play Framework 2.1.1 with support for controller dependency injection, asynchronous, non-blocking I/O, a code-reload workflow, database migrations, asset pipelining, and flexible deployment options has made it more attractive to developers. For this reason Play re-appears on the radar as something for teams to seriously consider when building web applications and services on the JVM. A word of caution however, Play embraces a functional programming style which, when working with the Java language, still translates into a plethora of static methods that may be difficult to unit test outside a running server. 
After some delays, mainly caused by patent claims from Apple, the W3C has now finalized the Touch Events recommendation. However, in the meantime,  Pointer Events , a newer, broader, and richer standard, is picking up momentum. We recommend considering Pointer Events for HTML interfaces that must work across different input methods. 
Polly.js  is a simple tool that helps teams test JavaScript websites and applications. Our teams particularly like that it enables them to intercept and stub HTTP interactions which allows for easier and faster testing of JavaScript code without having to spin up dependent services or components. 
Pose  is a simple CSS-like animation library for  React.js ,  React Native  and  Vue.js  frameworks. It is a declarative motion system that combines the simplicity of CSS syntax with the power and flexibility of JavaScript animations and interactions. 
PostCSS  is a  Node.js -based JavaScript framework for operating on an abstract syntax tree-based representation of CSS documents with a rich ecosystem of plugins. Often incorrectly thought of as a preprocessor (such as SASS or Less), we find that the real power of PostCSS comes from the number of things that can be done with the rich set of plugins which includes linting ( the stylelint plugin ), cross-compilation ( the sugarss plugin ), name-mangling to avoid selector collision ( the modules plugin ), boilerplate CSS code generation ( the autoprefixer plugin ),  minification  and many others. The different maturity levels of the plugins notwithstanding, PostCSS itself remains a simple and powerful framework for treating CSS like a full-fledged language for front-end development. PostCSS  is a  Node.js -based JavaScript framework for operating on an abstract syntax tree-based representation of CSS documents with a rich ecosystem of plugins. Often incorrectly thought of as a preprocessor (such as SASS or Less), we find that the real power of PostCSS comes from the number of things that can be done with the rich set of plugins which includes linting ( the stylelint plugin ), cross-compilation ( the sugarss plugin ), name-mangling to avoid selector collision ( the modules plugin ), boilerplate CSS code generation ( the autoprefixer plugin ),  minification  and many others. The different maturity levels of the plugins notwithstanding, PostCSS itself remains a simple and powerful framework for treating CSS like a full-fledged language for front-end development. 
PredictionIO  is an open source machine-learning server. Developers and data scientists can use it to build intelligent applications for prediction. Like all intelligent applications, PredictionIO has three parts: data collection and storage, model training, and model deployment and expose service. Developers could focus on implementing data-processing logic, model algorithm and prediction logic based on the corresponding interfaces and liberate themselves from data storage and model training deployment. In our experience, PredictionIO can support both small and large volumes of data with low concurrency. We mostly use PredictionIO to build predictive services for small and medium-sized enterprises or as a proof of concept when building more complex, customized prediction engines. 
Much like  Cypress  and  TestCafe ,  Puppeteer  is one of the web UI testing tools garnering praise from our teams. Puppeteer can have fine-grained control over headless browsers, obtain time-trace for performance diagnostics and more. Our teams have found Puppeteer to be stable as well as faster and more flexible than alternatives based on WebDriver. In the previous Radar we mentioned  Headless Chrome for front-end test . With the adoption of  Chrome DevTools Protocol  (CDP) by other browsers a new set of libraries is emerging for browser automation and testing. CDP allows for fine-grained control over the browser even in headless mode. New high-level libraries are being created using CDP for testing and automation.  Puppeteer  is one of these new libraries. It can drive headless Chrome through a single-page application, obtain time-trace for performance diagnostics and more. Our teams found it faster and also more flexible than alternatives based on WebDriver. 
Python 3  introduced many useful features that are not backward compatible with Python 2.x. It also removed numerous Python 2.x features that were maintained for backward compatibility, making Python 3 easier to learn and use and more consistent with the rest of the language. Our experience using Python 3 inÂ domains such as machine learning and web application development shows that both the language and most of its  supporting libraries  have matured for adoption. We were able to fork and patch minor issues of existing libraries or avoided using incompatible Python 2.x libraries that had been abandoned. If you are developing in Python we strongly encourage you to use Python 3. Python 3  introduced many useful features that are not backward compatible with Python 2.x. It also removed numerous Python 2.x features that were maintained for backward compatibility, making Python 3 easier to learn and use and more consistent with the rest of the language. Our experience using Python 3 inÂ domains such as machine learning and web application development shows that both the language and most of its  supporting libraries  have matured for adoption. We were able to fork and patch minor issues of existing libraries or avoided using incompatible Python 2.x libraries that had been abandoned. If you are developing in Python we strongly encourage you to use Python 3. Python 3  was a major change from the previous Python 2.x that introduced backwards incompatible changes. It was notable for actually removing languages features, making Python 3 easier to use and more consistent without reducing its power. This has led to problems in adoption as some widely used supporting libraries have not been ported, and Python developers often have to find new ways of doing things. Nonetheless the drive towards making a language simpler is to be applauded, and if you are actively developing in Python, then give Python 3 another look. 
Our teams have continued to use and appreciate the  PyTorch  machine learning framework, and several teams prefer PyTorch over  TensorFlow . PyTorch exposes the inner workings of ML that TensorFlow hides, making it easier to debug, and contains constructs that programmers are familiar with such as loops and actions. Recent releases have improved performance of PyTorch, and we&#39;ve been using it successfully in production projects. PyTorch  is a complete rewrite of the  Torch  machine learning framework from Lua to Python. Although quite new and immature compared to  Tensorflow , programmers find PyTorch much easier to work with. Because of its object-orientation and native Python implementation, models can be expressed more clearly and succinctly and debugged during execution. Although many of these frameworks have emerged recently, PyTorch has the backing of Facebook and broad range of partner organisations, including NVIDIA, which should ensure continuing support for CUDA architectures. ThoughtWorks teams find PyTorch useful for experimenting and developing models but still rely on TensorFlowâ€™s performance for production-scale training and classification. PyTorch  is a complete rewrite of the  Torch  machine learning framework from Lua to Python. Although quite new and immature compared to  Tensorflow , programmers find PyTorch much easier to work with. Because of its object-orientation and native Python implementation, models can be expressed more clearly and succinctly and debugged during execution. Although many of these frameworks have emerged recently, PyTorch has the backing of Facebook and broad range of partner organisations, including NVIDIA, which should ensure continuing support for CUDA architectures. ThoughtWorks teams find PyTorch useful for experimenting and developing models but still rely on TensorFlowâ€™s performance for production-scale training and classification. 
Q  is a fully Promises/A+ compliant implementation in JavaScript that lets users compose promises arbitrarily deeply without the need for the deeply nested callbacks that obscure control flow. Q takes care of threading fulfilled values and rejected promises through the appropriate code paths. The space of Promises/A+ compliant libraries is currently very active with alternatives like  Bluebird  also rapidly gaining mindshare. Q  is a fully Promises/A+ compliant implementation in JavaScript that lets users compose promises arbitrarily deeply without the need for the deeply nested callbacks that obscure control flow. Q takes care of threading fulfilled values and rejected promises through the appropriate code paths. The space of Promises/A+ compliant libraries is currently very active with alternatives like  Bluebird  also rapidly gaining mindshare. 
Quantum computing currently exists in a twilight zone of being available for testing without having arrived yet. While we&#39;re still waiting for the hardware to arrive, we can experiment with and learn from languages and simulators. Although IBM and others have been making good progress, we&#39;ve paid particular attention to Microsoft&#39;s efforts based around the  Q#  language and its simulator (32 qubits locally and 40 on Azure). If you want to start wrapping your head around the potential future of programming, check out their set of  samples on GitHub . 
Quarkus  is a cloud-native, container-first framework by Red Hat for writing Java applications. It has a very fast startup time (tens of milliseconds) and has low memory utilization which makes it a good candidate for FaaS or frequent scaling up and down in a container orchestrator. Like  Micronaut , Quarkus achieves this by using ahead-of-time compilation techniques to do dependency injection at compile time and avoid the runtime costs of reflection. It also works well with  GraalVM &#39;s Native Image which further reduces startup time. Quarkus supports both imperative and reactive models. Along with Micronaut and  Helidon , Quarkus is leading the charge on the new generation of Java frameworks which attempt to address startup performance and memory without sacrificing developer effectiveness. It&#39;s gained a lot of community attention and is worth keeping an eye on. 
Most of our iOS teams are now using the  Quick  and  Nimble  pairing for their unit tests. In the  RSpec  family of behavior-driven development (BDD) testing tools, it provides very readable tests (with describe blocks) across  Swift  and Objective-C and has good support for asynchronous testing. Most of our iOS teams are now using the  Quick  and  Nimble  pairing for their unit tests. In the  RSpec  family of behavior-driven development (BDD) testing tools, it provides very readable tests (with describe blocks) across  Swift  and Objective-C and has good support for asynchronous testing. 
R is traditionally used as stand alone analysis tool by research teams. With improvements in packages like Rook and RJSONIO, it has become trivial to wrap the computational logic and expose it as an API. ThoughtWorks teams are using  R as Compute platform  to crunch large datasets in real time, using in-memory storage integrated with enterprise systems. R is traditionally used as stand alone analysis tool by research teams. With improvements in packages like Rook and RJSONIO, it has become trivial to wrap the computational logic and expose it as an API. ThoughtWorks teams are using  R as Compute platform  to crunch large datasets in real time, using in-memory storage integrated with enterprise systems. 
Rapidoid  is a collection of web framework modules, including a fast low-level HTTP server implemented from scratch on top of Java NIO. Clever usage of off-heap input/output buffers, object pools and thread-local data structures provide Rapidoid an edge over other NIO-based servers like  Netty . Being a fairly new project, Rapidoid has yet to implement a few features like built-in cache and SSL support; we suggest you check the  roadmap  for updates. 
Rasa  is a new entrant in the area of chatbots. Instead of using a simple decision tree it uses neural networks to map intent and internal state to a response. Rasa integrates with natural language processing solutions such as  spaCy ; and, unlike other solutions we&#39;ve featured in the Radar, Rasa is  open source software  and can be self-hosted, which makes it a viable solution when ownership of data is of concern. Our experiences with using Rasa Stack for an internal application have been positive. 
React Hooks  have introduced a new approach to managing stateful logic; given React components have always been closer to functions than classes, Hooks have embraced this and brought state to the functions, instead of taking function as methods to the state with classes. Based on our experience, Hooks improve reuse of functionality among components and code readability. Given Hooksâ€™ testability improvements, using  React Test Renderer  and  React Testing Library , and their growing community support, we consider them our approach of choice. Earlier this year,  React Hooks  were introduced to the popular JavaScript framework. They make it possible to use state and other React features without writing a class, offering a cleaner approach than higher-order components or render-props for use cases. Libraries such as  Material UI  and  Apollo  have already switched to using Hooks. There are some issues with testing Hooks, especially with Enzyme, which contributed to our reassessment of  Enzyme  as the tool of choice. 
In the avalanche of front-end JavaScript frameworks,  React.js  stands out due to its design around a reactive data flow. Allowing only one-way data binding greatly simplifies the rendering logic and avoids many of the issues that commonly plague applications written with other frameworks. We&#39;re seeing the benefits of React.js on a growing number of projects, large and small, while at the same time we continue to be concerned about the state and the future of other popular frameworks like  AngularJS . This has led to React.js becoming our default choice for JavaScript frameworks. One benefit of the ongoing avalanche of front-end JavaScript frameworks is that occasionally a new idea crops up that makes us think.  React.js  is a UI/view framework in which JavaScript functions generate HTML in a reactive data flow.  It differs significantly from frameworks like  AngularJS  in that it only allows one-way data bindings, greatly simplifying the rendering logic. We have seen several smaller projects achieve success with React.js, and developers are drawn to its clean, composable approach to componentization. One benefit to the ongoing avalanche of front-end JavaScript frameworks is that occasionally, a new idea crops up that makes us think.   React.js  is a UI/View framework in which JavaScript functions generate HTML in a reactive data flow.  We have seen several smaller projects achieve success with React.js and developers are drawn to its clean, composeable approach to componentization. One benefit to the ongoing avalanche of front-end JavaScript frameworks is that occasionally, a new idea crops up that makes us think.   React.js  is a UI/View framework in which JavaScript functions generate HTML in a reactive data flow.  Although we are wary of mixing code and markup, it results in UI components that are nicely encapsulated and composable.  React.js is getting a lot of developer attention and will benefit from more tools and examples   becoming available. 
We are seeing continued success with  React Native  for rapid cross-platform mobile development. Despite some churn as it undergoes continuing development, the advantages of trivial integration between native and nonnative code and views, the rapid development cycle (instant reload, chrome debugging, Flexbox layout) and general growth of the React style is winning us over. As with many frameworks, care needs to be taken to keep your code well structured, but diligent use of a tool like  Redux  really helps here. Yet another entrant into the cross-platform mobile development world, Facebookâ€™s  React Native  brings the React.js programming model to iOS and Android developers. React Native programs are written in JavaScript, but unlike a hybrid framework such as Ionic, React Native gives developers access to native UI components on the target platform. This is an approach weâ€™ve seen before (e.g.,  Calatrava ), but React Native has already inspired a substantial developer community and builds on the momentum generated by React.js. This framework could play a significant role in the future of mobile app development. 
The JavaScript world moves pretty fast, and as we gain more experience using a framework our recommendations change. The  React Testing Library  is a good example of a framework that with deeper usage has eclipsed the alternatives to become the sensible default when testing React-based frontends. Our teams like the fact that tests written with this framework are less brittle than with alternative frameworks such as  Enzyme , because you&#39;re encouraged to test component relationships individually as opposed to testing all implementation details. This mindset is brought by  Testing Library  which React Testing Library is part of and which provides a whole family of libraries for  Angular  and  Vue.js , for example. The JavaScript world moves pretty fast, and as we gain more experience using a framework our recommendations change. The  React Testing Library  is a good example of a framework that with deeper usage has eclipsed the alternatives to become the sensible default when testing React-based frontends. Our teams like the fact that tests written with this framework are less brittle than with alternative frameworks such as  Enzyme  because you&#39;re encouraged to test component relationships individually as opposed to testing all implementation details. As the pace of change in JavaScript frameworks has slowed, our teams have more time to work with specific frameworks and are gaining deeper insights as a result. With  React  and the dominant testing framework,  Enzyme , we&#39;ve observed a worrying trend of unit tests becoming tightly coupled to implementation details without providing â€” because the focus is on shallow details â€” much confidence that features work as expected. These unit tests make evolving the design difficult and they shift too much responsibility up the test pyramid to functional testing. This has made us revisit the idea of  subcutaneous testing . Additionally, because of its design,  Enzyme has issues  trying to keep up with React&#39;s development. All this has pushed us toward assessing  react-testing-library  as a new framework for testing React applications. 
Distributed systems often utilize multithreading, event-based communication and nonblocking I/O to improve the overall system efficiency. These programming techniques impose challenges such as low-level threading, synchronization, thread safety, concurrent data structures, and non-blocking I/O. The open source  ReactiveX  library beautifully abstracts away these concerns, provides the required application plumbing, and extends the   observable pattern  on streams of asynchronous events. ReactiveX also has an active developer community and supports a growing list of languages, the most recent addition being  RxSwift . It also implements binding to mobile and desktop platforms. The  reactive architecture  keeps spreading across platforms and paradigms simply because it solves a common problem in an elegant way, hiding inevitable application plumbing in a nice encapsulation. Reactive Programming deals with streams or values that change over time. Using elements of data flow, implicit concurrency and transparent event propagation, these techniques enable efficient handling of events on a large scale with a high degree of efficiency and low latency. In the previous radar, we mentioned Reactive Extensions in .NET due to the extensive work done by Microsoft in making Rx a core part of the .NET framework. Since then, with the introduction of the Reactive Cocoa library for Objective C, the Java port of Reactive Extensions, the React JavaScript library, the Elm language based on Haskell &amp; the Flapjax JavaScript library, we are extending this blip to include Reactive Extensions across languages. 
We&#39;ve talked about  Reactor  in the previous Radars. It has continued to gain traction in many of our projects. With the Spring ecosystem embracing Reactor, it has become the dominant implementation of  Reactive Streams . Reactive systems come with improved scalability and resilience but with increased cost of debugging and a steeper learning curve. For those projects where this tradeoff is acceptable, Reactor has proven to be a good choice. Some of our projects have observed significant improvements in scalability once they moved to Reactor and the rest of the Reactive stack. With  R2DBC  we are starting to get reactive support for RDBMS drivers which addresses one of the weaknesses of reactive services. Reactor  is a library for building non-blocking applications on the JVM â€” version 8 and above â€” based on the  Reactive Streams  specification. Reactive programming emphasizes moving from imperative logic to asynchronous, non-blocking and functional style code, especially when dealing with external resources. Reactor implements the reactive stream specification and provides two publisher APIs â€” Flux (0 to N elements) and Mono (0 or 1 element) â€” to effectively model push-based stream processing. Reactor project is well suited for microservices architecture and offers back pressureâ€“ready network engines for HTTP, WebSockets, TCP and UDP traffic. 
Reagent  has emerged as a lightweight minimalist alternative to Om for wrapping React.js in ClojureScript. Whereas Om provides a comprehensive Clojure-idiomatic front-end programming framework, Reagent takes advantage of Clojureâ€™s expressiveness to focus on simple components and a readable DSL for writing HTML.  By representing HTML in Clojure data, Reagent retains the performance and understandability of React.js without embedding foreign markup in the code. 
ReasonML  is an interesting new language based on OCaml with a sprinkling of C-like syntax and uses JavaScript as the default compilation target. Created by Facebook, it allows embedded JavaScript snippets and JSX templating with good  React  integration. It aims to be approachable for JavaScript developers and leverages that ecosystem, while providing type safety in a functional language. 
We&#39;ve been enjoying how  Recharts  integrates  D3  charts into  React.js  in a clean and declarative manner. 
More and more teams using  React  are reevaluating their options for state management, something we also mention in our reassessment of  Redux . Now, Facebook â€” the creators of React â€” have published  Recoil , a new framework for managing state, which came out of an internal application that had to deal with large amounts of data. Even though we currently do not have much practical experience with Recoil, we see its potential and promise. The API is simple and easy to learn; it feels like idiomatic React. Unlike other approaches, Recoil provides an efficient and flexible way to have state shared across an application: it supports dynamically created state by derived data and queries as well as app-wide state observation without impairing code splitting. 
We&#39;ve decided to move  Redux  back into the Trial ring to show that we no longer consider it the default approach for state management in  React  applications. Our experience shows that Redux is still a valuable framework in many cases but compared to other approaches, it also leads to more verbose and harder-to-follow code. Throwing  Redux Sagas  into the mix usually compounds this issue. As an alternative, you can often use the features in recent versions of React to manage state effectively without an additional framework. However, we want to highlight that when you reach the point at which your simple state management solution starts to become complex, it might be worth reaching for Redux after all or perhaps even Facebookâ€™s recently published  Recoil . With the increasing complexity of single-page JavaScript applications, we have seen a more pressing need to make client-side state management predictable.  Redux , with its  three principles  of restrictions for updating state, has proven to be invaluable in a number of projects we have implemented.  Getting Started with Redux  and  idiomatic Redux  tutorials are a good starting point for new and experienced users. Its minimal library design has spawned a rich set of tools, and we encourage you to check out the  redux-ecosystem-links  project for examples, middleware and utility libraries. We also particularly like the testability story: Dispatching actions, state transitions and rendering can be unit-tested separately from one another and with minimal amounts of mocking. With the increasing complexity of single-page JavaScript applications, we have seen a more pressing need to make client-side state management predictable.  Redux , with its  three principles  of restrictions for updating state, has proven to be invaluable in a number of projects we have implemented.  Getting Started with Redux  and  idiomatic Redux  tutorials are a good starting point for new and experienced users. Its minimal library design has spawned a rich set of tools, and we encourage you to check out the  redux-ecosystem-links  project for examples, middleware and utility libraries. We also particularly like the testability story: Dispatching actions, state transitions and rendering can be unit-tested separately from one another and with minimal amounts of mocking. Redux  is a great, mature tool that has helped many of our teams reframe how they think about managing state in client-side apps. Using a  Flux -style approach, it enables a loosely coupled state-machine architecture that&#39;s easy to reason about. We&#39;ve found it a good companion to some of our favored JavaScript frameworks, such as  Ember  and  React . 
Our continued use of node.js on new production applications has re-enforced our need for reliable packaging of JavaScript code and libraries. The Node Package Manager (npm) is an important part of the node.js ecosystem and a useful tool for packaging node.js applications. Developers of browser applications with large amounts of JavaScript or CoffeeScript should consider Require.js to help with structuring their code and loading dependencies at run time 
As adoption continues to expand, so does the size of many JavaScript codebases. To improve modularity of code and help manage this, we are seeing teams embrace libraries such as Require.js. Using the Asynchronous Module Definition (AMD) format, code is split into modules, easing development and maintenance, and an optimization tool then combines and minifies scripts for production deployment. 
Resilience4j  is a lightweight fault tolerance library inspired by Netflix  Hystrix . We like its lightweight and modular structure where we pull in specific modules for specific capabilities such as circuit-breaking, rate-limiting, retry, and bulkhead. While  service meshes  are taking on some of the fault tolerance capabilities, fault tolerance libraries continue to remain a key component of our systems for more nuanced domain-specific fault tolerance behavior and for non-containerized services. With Hystrix going into  maintenance mode , Resilience4j becomes a default choice in the Java ecosystem. It can work with synchronous APIs as well as reactive ones. It also surfaces metrics to  dropwizard metrics ,  Prometheus  and others using additional modules. 
We are excited that the  Redux  paradigm has made its way to Swift-land in the form of  ReSwift . Weâ€™ve found real benefits in the simplicity and readability of codebases once state and state changes are managed in a central place and common idiom. This also helps with building &#34;offline first&#34; applications. 
Retrofit  offers a reliable way to build HTTP clients on Android projects by converting a REST API into a Java interface. Retrofit integrates with OkHttp and allows developers to provide custom error handling for requests. It does JSON parsing automatically using Gson and has a very well supported community. 
RIBs  â€” which is short for router, interactor and builder â€” is a cross-platform architecture mobile framework from Uber. The key idea of RIBs is to decouple business logic from the view tree, and thus ensure the app is driven by business logic. This is actually an application of  Clean Architecture  in mobile application development. By applying consistent architecture patterns across native Android and iOS, RIBs provides clear statement management and good testability. We advise putting business logic in the back-end service rather than leak it into the view, so if you do have a complicated mobile application, RIBs can help manage this complexity. 
In the Android application-development world,  Robolectric  is a unit-testing framework that has been used by multiple teams within our technical community. It offers the best option among those available for writing real unit tests that extend or interact directly with Android components and support JUnit tests. We caution, though, that because it is an implementation of the Android SDK, there might be device-specific issues for some tests that pass in Robolectric. To manually mock all the Android dependencies, ensuring only test of the system-in-test will require a lot of complex code, and this framework addresses this effectively. 
Room  is a persistence library to access SQLite on Android. It makes database access code much simpler, with minimal boilerplate code, and more robust, with compile-time verification of SQL queries. Our developers like its complete integration with observable queries, using  LiveData . Room is one of the Android  Jetpack  components that were created to make application development on Android easier. 
This language/framework was included in this edition of the Radar for visibility. We felt that there wasn&#39;t anything substantial to add to the discourse around it, but that it was important to keep this in view. This language/framework was included in this edition of the Radar for visibility. We felt that there wasn&#39;t anything substantial to add to the discourse around it, but that it was important to keep this in view. 
Introducing a Ruby compiler and toolchain for developing iOS applications, RubyMotion has unsurprisingly caused quite a stir in the ThoughtWorks development community. There continues to be a need to understand the underlying iOS APIs and some Objective-C when building applications, but there are clear benefits for those who find working with the Ruby language and tools more comfortable. 
The  Rust  programming language continues to grow in popularity and has been voted Stack Overflow&#39;s &#34;most loved&#34; language by developers five years in a row. We like it too. It&#39;s a fast, safe and expressive language that is increasing in utility as its ecosystem grows. For example, Rust is starting to be used for data science and machine learning and can give a  significant performance boost . Also,  Materialize  is a streaming-oriented, low-latency database written in Rust. Rust  is continuously gaining in popularity. We&#39;ve had heated discussions about which is better, Rust or C++/Go, without a clear winner. However, we&#39;re glad to see Rust has improved significantly, with more built-in APIs being added and stabilized, including  advanced async support , since we mentioned it in our previous Radar. In addition, Rust has also inspired the design of new languages. For example, the  Move language  on Libra borrows Rust&#39;s way of managing memory to manage resources, ensuring that digital assets can never be copied or implicitly discarded. Since we last featured it on the Radar in January 2015, we&#39;ve seen steadily increasing interest in  Rust . Some of our clients are now using Rust, mostly in the context of infrastructure tooling but also in high-powered embedded devices. Interest was fuelled by a growing ecosystem as well as improvements to the language itself. The latter included straightforward performance improvements but also changes that make Rust more intuitive, for example the change to non-lexical scoping. Most of the significant changes are included in the Rust 2018 standard released last December. Rust  is a system programming language with modern affordances. It features a rich typing system, safe memory model and task-based concurrency. Compared to the Go language, Rust is more friendly to people who would like to write code in a functional style. Rust  is a system programming language with modern affordances. It features a rich typing system, safe memory model and task-based concurrency. Compared to the Go language, Rust is more friendly to people who would like to write code in a functional style. 
The  SAFE stack â€”short for  Suave ,  Azure ,  Fable , and  Elmish â€”brings a number of technologies into a coherent stack for web development. It&#39;s built around the F# programming language, both on the server side and in the browser, and therefore has a focus on functional, type-safe programming with an asynchronous approach. It offers productivity features such as hot reloading and lets you substitute parts of the stack, for example, the server-side web framework or the cloud provider. 
Sarama  is a Go client library for  Apache Kafka . If youâ€™re developing your APIs in Go, you&#39;ll find Sarama quite easy to set up and manage as it doesn&#39;t depend on any native libraries. Sarama has two types of APIs â€” a high-level API for easily producing and consuming messages and a low-level API for controlling bytes on the wire. 
CSS has been an extremely popular and effective DSL for styling web pages. It does, however, have some annoying limitations which have led to a number of languages that build on CSS to make it easier to write and modify. Weâ€™ve had good experiences with SASS, SCSS, and LESS. 
Scala is a large language that is popular because of its approachability for new developers. This banquet of features is a problem because many aspects of Scala, like implicit conversions and dynamics, can get you into trouble. To successfully use Scala, you need to research the language and have a very strong opinion on which parts are right for you, creating your own definition of  Scala, the good parts . You can disable the parts you do not want using a system called feature flags. In the previous radar we had two JVMbased functional programming languages, Clojure and Scala, in our Assess category. We had expressed a slight preference for Clojure because it is the smaller and more focused language. Since the last radar we have realized that the wider applicability of Scala makes it more approachable for enterprise developers, and we have witnessed great successes in the adoption of Scala. Consequently we have moved Scala into our Trial category. Pay careful attention to the idiomatic use of Scala if it is introduced to a new team to avoid &#34;Java without semicolons&#34; or Perl styles. The functional languages F#, Clojure and Scala still reside in the assess ring of the radar. Interest in functional languages continues to grow. Two characteristics of functional languages in particular are driving this interest, immutability with its implications for parallelism and functions as first class objects. While the introduction of closures to C# brings some of the latter capability, functional languages are almost synonymous with immutability. The placement of these languages within the assess ring indicates our view of their relative maturity and appropriateness. F#, based on OCaml, is fully supported within the Visual Studio toolset. F# includes support for objects and imperative constructs in addition to functional language constructs in a natural way. Scala, like F#, combines the object and functional paradigms, although the syntax of Scala is more Java-like. Clojure began as a JVM language and is now available on the .NET CLR. Clojure does allow for mutable state although it has an extensive set of immutable persistent data structures, all supporting multi-threaded applications. There are many similarities between these three languages, but at the moment we believe F# and Clojure to be better suited to most organizations for assessing than Scala. More work clearly needs to be done to validate this assertion. In the previous radar, we lumped functional languages together in a group. For this version, weâ€™ve exploded that group and started calling out the ones interesting to us. Of the current crop of functional languages, the one we like the most is Clojure: a simple, elegant implementation of Lisp on the JVM. The other two that we fi nd interesting are Scala (a re-thinking of Java in functional form) and F#, the OCaml derivative from Microsoft that now appears â€œin the boxâ€� in Visual Studio 2010. 
We think it is essential to inspire the next generation of technologists. Scratch, Alice, and Kodu are programming languages that rely on visual environments and building blocks as teaching devices. They offer exciting possibilities for educational programs and organizations intending to foster programming knowledge in environments beyond academia. 
We have a number of reservations about the use of HTML5 WebSockets. By allowing the server to initiate actions on the browser, WebSockets departs from the connectionless, request/response model that underpins the World Wide Web today. Security is another big risk with WebSockets. For example, the standard does not impose any cross-origin request policy. However, we do recognize that in certain monitoring or alerting applications, WebSockets can be very useful. If you need to build a .NET WebSockets server,  SignalR  conveniently implements much of the additional code you need for a robust production application. This includes some recommended security practices such as validating connection tokens and activating SSL when encryption is needed. Although ThoughtWorks teams have been very happy with SignalR, there are still fundamental issues with WebSockets that you should consider before diving in. 
Micro-frameworks are emerging as a way to handle increasing complexity in applications both on client- and server-side. Sinatra was one of the first examples of that trend in the server-side space, exposing a lightweight DSL to build fast services that can be easily composed. Similar offerings are available for other languages, including Spark for Java, Flask for Python, Sclatra for Scala, Compojure for Clojure and Nancy for .NET. Micro-frameworks are emerging as a way to handle increasing complexity in applications both on client- and server-side. Sinatra was one of the early precursors of that trend in server-side space, exposing a lightweight DSL to build fast services that can be easily composed. Flask, Scalatra and Compojure are similar offerings for Python, Scala and Clojure respectively. 
single-spa  is a JavaScript framework for bringing together multiple  micro frontends  in a single front-end application. Although we advise against  micro frontend anarchy , the use of micro frontends as an excuse to mix and match multiple frameworks, single-spa supports just that. We understand that there are legitimate scenarios such as upgrading to a new revision of a framework across multiple micro frontends where integration across multiple frameworks is necessary. single-spa has been a go-to framework for micro frontend integration for our teams, and they&#39;re finding it to work well with  SystemJS  and managing different versions of a single dependency. single-spa  is a JavaScript metaframework that allows us to build  micro frontends  using different frameworks that can coexist in a single application. In general, we don&#39;t recommend using more than one framework for an application, but there are times when we can&#39;t avoid doing so. For instance, single-spa can be quite useful when you&#39;re working with a legacy application and you want to experiment by developing a new feature, with either a new version of the existing framework or a completely different one. Given the short life span of many JavaScript frameworks, we see a need for a solution that would allow for future framework changes and localized experimentation, without affecting the entire application. single-spa seems to be a good start in that direction. 
Modern ML models are very complex and require massive amounts of labeled training data sets to learn from.  Snorkel  started at the Stanford AI lab with the realization that manually labeling data is very expensive and often not feasible. Snorkel allows us to label training data programmatically via the creation of labeling functions. Snorkel employs supervised learning techniques to assess the accuracies and correlations of these labeling functions, and then reweighs and combines their output labels, leading to high-quality training labels. The creators of Snorkel have since come out with a commercial platform called  Snorkel Flow . While Snorkel itself is no longer actively developed, it&#39;s still significant for its ideas on the use of weakly supervised methods to label data. 
Programming for smart contracts requires a more expressive language than a  scripting system for transactions .  Solidity  is the most popular among the new programming languages designed for smart contracts. Solidity is a contract-oriented, statically typed language whose syntax is similar to JavaScript. It provides abstractions for writing self-enforcing business logic in smart contracts. The toolchain around Solidity is growing fast. Nowadays, Solidity is the primary choice on the  Ethereum  platform. Given the immutable nature of deployed smart contracts, it should go without saying that rigorous testing and audit of dependencies is vital. Programming for smart contracts requires a more expressive language than a  scripting system for transactions .  Solidity  is the most popular among the new programming languages designed for smart contracts. Solidity is a contract-oriented, statically typed language whose syntax is similar to JavaScript. It provides abstractions for writing self-enforcing business logic in smart contracts. The toolchain around Solidity is growing fast. Nowadays, Solidity is the primary choice on the  Ethereum  platform. Given the immutable nature of deployed smart contracts, it should go without saying that rigorous testing and audit of dependencies is vital. 
The adoption of a new language typically spawns the emergence of new tools that support mature engineering practices such as test automation.  Kotlin  is no exception.  Spek  is a testing frameworkâ€”inspired by well-known tools such as  Cucumber ,  RSpec  and  Jasmine â€”that writes tests in Gherkin and Specification, allowing teams to bring mature practices such as  behaviour-driven development  into the Kotlin space. 
Spray/akka-http  is a suite of lightweight Scala libraries providing client/server RESTful support on top of Akka. It fully embraces the Actor-, Future-, and Stream-based programming models used by the underlying platform. This lets you work on RESTful applications with idiomatic Scala code without worrying about wrapping around other Java libraries. 
A lot of work has gone into  Spring Boot  to reduce complexity and dependencies, which largely alleviates our previous reservations. If you live in a Spring ecosystem and are moving to microservices, Spring Boot is now the obvious choice. For those not in Springland,  Dropwizard  is also worthy of serious consideration. Spring Boot  allows easy setup of standalone Spring-based applications. It&#39;s ideal for pulling up new microservices and easy to deploy. It also makes data access less of a pain, thanks to the JPA mappings through Spring Data. We like that Spring Boot simplifies Java services built with Spring but have learned to be cautious of the many dependencies. Spring still lurks just beneath the surface. If youâ€™re writing microservices with Java, you might also consider using  Dropwizard  or a microframework like  Spark  to get the benefits of Spring Boot without the enormous weight of Spring. Spring Boot  allows easy set up of standalone Spring-based applications. It&#39;s ideal for pulling up new microservices and easy to deploy. It also makes data access less of a pain due to the hibernate mappings with much less boilerplate code. We like that Spring Boot simplifies Java services built with Spring, but have learned to be cautious of the many dependencies. Spring still lurks just beneath the surface. Spring boot  allows easy set up of standalone Spring-based applications. It&#39;s ideal for pulling up new microservices and easy to deploy. It also makes data access less of a pain due to the hibernate mappings with much less boilerplate code. Spring Boot  allows easy set up of standalone Spring-based applications. It&#39;s ideal for pulling up new microservices and easy to deploy. It also makes data access less of a pain due to the hibernate mappings with much less boilerplate code. 
Spring Cloud  continues to evolve and add interesting new features. Support for binding to  Kafka Streams , for example, in the spring-cloud-streams project makes it relatively easy to build message driven applications with connectors for Kafka and RabbitMQ. The teams we have using it appreciate the simplicity it brings to using sometimes complex infrastructure, such as  ZooKeeper , and support for common problems that we need to address when building distributed systems, tracing with the  spring-cloud-sleuth  for example. The usual caveats apply but we&#39;reÂ successfully using it on multiple projects. Teams building systems composed of microservices need to think about coordination techniques such as service discovery, load balancing, circuit breaking and health checking. Many of these techniques require teams to set up tooling, which is not always trivial. The  Spring Cloud  project provides tools for developers so they can use these coordination techniques in the familiar Spring environment. These tools support  Consul ,  ZooKeeper  and the  Netflix OSS full stack , all tools that we like. Simply put, it makes it easy to do the right thing with these tool sets. Although our usual concerns with Spring still stand, namely that it hides too much of the complexity, you should consider Spring Cloud if you are in the ecosystem and need to solve these problems. 
Streamlit  is an open-source application framework in Python used by data scientists for building good-looking data visualization applications. Streamlit stands out from competitors such as Dash with its focus on rapid prototyping and support for a wide range of visualization libraries, including  Plotly  and  Bokeh . For data scientists who need quick showcases during the experimentation cycle, Streamlit is a solid choice. We&#39;re using it in a few projects and like how we can put together interactive visualizations with very little effort. 
The  Kotlin  ecosystem keeps growing and more libraries are taking advantage of Kotlin language features to replace their Java alternatives.  Strikt  is an assertion library that allows you to write test assertions in a very fluent style. It uses Kotlin features such as blocks and lambdas to help make your tests less verbose while maintaining readability. Strikt also supports building custom assertions, which can make your tests more domain specific. 
Using tagged template literals  styled components  make it possible to put the CSS needed to style a React component directly into the JavaScript code that creates the component. This greatly reduces the pain with managing CSS and obviates the need for naming conventions or other means of avoiding naming conflicts in CSS. Developers can see the styling when looking at the component definition, and they don&#39;t have to memorize several megabytes worth of CSS. Of course, placing the CSS into the JavaScript code can make it harder to get a consistent view across the styling of different components, which is why we recommend understanding the trade-offs with this approach. 
We continue to see new front-end JavaScript frameworks, and  Svelte  stands out as a promising new component framework. Unlike other frameworks that leverage the virtual DOM, Svelte compiles your code into vanilla framework-less JavaScript code that surgically updates the DOM directly. However, it&#39;s only a component framework; if you&#39;re planning to build feature-rich applications, consider assessing  Sapper  together with Svelte. 
Swift  is now our default choice for development in the Apple ecosystem. With the release of Swift 2, the language approached a level of maturity that provides the stability and performance required for most projects. A good number of libraries that support iOS developmentâ€” SwiftyJSON ,  Quick , etc.â€”are now migrated over to Swift, which is where the rest of the applications should follow. Swift has now been open sourced, and we are seeing a community of developers dedicated to continuously improving development in iOS. A year after its public debut,  Swift  is now our default choice for development in the Apple ecosystem. With the recent release of Swift 2, the language approaches a level of maturity that provides the stability and performance required for most projects. Swift still has issues, especially around tool support, refactoring and testing. However, we feel that these are not substantial enough to warrant avoiding Swift. At the same time, porting large, existing Objective-C codebases is unlikely to pay off. The announcement that Swift will become open source software is a further positive sign. We are hopeful that this will not just be another dumping of internally developed code into a public repository, because Apple has clearly stated that community contributions are encouraged and will be accepted. With some real-world experience under our belt,  Swift  still shows a lot of promise. Some of the problems, like long compile times, are being addressed. However, continued language changes cause extra development effort and make building older versions of your own software burdensome. Testing and refactoring also remain painful. On balance, though, you should still consider Swift when starting new development projects for the Apple ecosystem. Swift,  Appleâ€™s new development language, contains many improvements over the perennial Objective-C, including emphasis on functional programming and modern syntax. In most ways, this is an upgrade if you are coding on the Apple platform. 
Weâ€™re in favor of asynchronous and  reactive styles of programming  especially for network I/O-bound distributed systems. Reactive libraries often sit on top of a lower level nonblocking communication framework such as  Netty . Recently  SwiftNIO , an open source nonblocking networking framework from Apple, has grabbed our attention. SwiftNIO is similar to Netty but written in Swift. Itâ€™s currently supported on MacOS and Ubuntu and implements HTTP as a higher-level protocol. Weâ€™re excited to see the usage of this framework and integration of it into higher-level application frameworks and other protocols. 
Apple has taken a big step forward with their new  SwiftUI  framework for implementing user interfaces on the macOS and iOS platforms. We like that SwiftUI moves beyond the somewhat kludgy relationship between Interface Builder and Xcode and adopts a coherent, declarative and code-centric approach. You can now view your code and the resulting visual interface side by side in Xcode 11, making for a much better developer experience. The SwiftUI framework also draws inspiration from the  React.js  world that has dominated web development in recent years. Immutable values in view models and an asynchronous update mechanism make for a unified reactive programming model. This gives developers an entirely native alternative to similar reactive frameworks such as  React Native  or  Flutter . SwiftUI definitely represents the future of Apple UI development, and although new, it has shown its benefits. We&#39;ve been having great experience with it â€” and its shallow learning curve. It&#39;s worth noting that you should know your customer&#39;s use case before jumping into using SwiftUI, given that it doesn&#39;t support iOS 12 or below. Apple has taken a big step forward with their new  SwiftUI  framework for implementing user interfaces on macOS and iOS platforms. We like that SwiftUI moves beyond the somewhat kludgy relationship between Interface Builder and XCode and adopts a coherent, declarative and code-centric approach. You can now view your code and the resulting visual interface side by side in XCode 11, making for a much better developer experience. The SwiftUI framework also draws inspiration from the  React.js  world that has dominated web development in recent years. Immutable values in view models and an asynchronous update mechanism make for a unified reactive programming model. This gives developers an entirely native alternative to similar reactive frameworks such as  React Native  or  Flutter . Although SwiftUI definitely represents the future of Apple UI development, it is quite new and it will take time to smooth out the rough edges. We look forward to improved documentation and a community of developers who can establish a set of practices for testing and other engineering concerns. 
SWR  is a  React Hooks  library for fetching remote data. It implements the  stale-while-revalidate  HTTP caching strategy. SWR first returns data from cache (stale), then sends the fetch request (revalidate) and finally refreshes the values with the up-to-date response. Components receive a stream of data, first stale and then fresh, constantly and automatically. Our developers have had a good experience using SWR, dramatically improving the user experience with always having data on the screen. However, we caution teams to only use SWR caching strategy when appropriate for an application to return stale data. Note that  HTTP  requires that caches respond to a request with the most up-to-date response held that is appropriate to the request, and only in  carefully considered circumstances  is a stale response allowed to be returned. 
Taiko  is a node.js library with a clear and concise API to assist with chrome or chromium browser automation. You can leverage Taiko&#39;s smart selectors and write reliable tests as the structure of the web application evolves. There&#39;s no need for ID, CSS or XPath selectors or adding explicit waits (for XHR requests) in test scripts. The interactive REPL recorder comes in handy when you want to develop the tests side by side as you explore the functionality. Although you could use Taiko independently, we&#39;ve had good success using it with  Gauge . 
CSS tools and frameworks offer predesigned components for fast results; after a while, however, they can complicate customization.  Tailwind CSS  proposes an interesting approach by providing lower-level utility CSS classes to create building blocks without opinionated styles and aiming for easy customization. The breadth of the low-level utilities allows you to avoid writing any classes or CSS on your own which leads to a more maintainable codebase in the long term. It seems that Tailwind CSS offers the right balance between reusability and customization to create visual components. 
If you need to ingest data from relational databases into a Kafka topic, consider  Tamer , which labels itself &#34;a domesticated JDBC source connector for Kafka.&#34; Despite being a relatively new framework, we&#39;ve found Tamer to be more efficient than the Kafka JDBC connector, especially when huge amounts of data are involved. 
In the last issue we featured  PyTorch , a deep-learning modeling framework that allows an imperative programming style. Now  TensorFlow Eager Execution  provides this imperative style in  TensorFlow  by enabling execution of modeling statements outside of the context of a session. This improvement could provide the ease of debugging and finer-grained model control of PyTorch with the widespread popularity and performance of TensorFlow models. The feature is still quite new so weâ€™re anxious to see how it performs and how itâ€™ll be received by the TensorFlow community. 
TensorFlow Lite  is the designated successor of  TensorFlow Mobile , which we mentioned in our previous Radar. Like Mobile it is a lightweight solution tuned and optimized for mobile devices (Android and iOS). We expect the standard use case to be the deployment of pretrained models into mobile apps but TensorFlow Lite also supports on-device learning which opens further areas of application. 
TensorFlow Mobile  makes it possible for developers to incorporate a wide range of comprehension and classification techniques into their iOS or Android applications. This is particularly useful given the range of sensor data available on mobile phones. Pretrained TensorFlow models can be loaded into a mobile application and applied to inputs such as live video frames, text or speech. Mobile phones present a surprisingly opportune platform for implementing these computational models. TensorFlow models are exported and loaded as protobuf files, which can present some problems for implementers. Protobuf&#39;s binary format can make it hard to examine models and requires that you link the correct protobuf library version to your mobile app. But local model execution offers an attractive alternative to  TensorFlow Serving  without the communication overhead of remote execution. 
With its 2.0 release,  TensorFlow  retains its prominence as the industryâ€™s leading machine learning framework. TensorFlow began as a numerical processing package that gradually expanded to include libraries supporting a variety of ML approaches and execution environments, ranging from mobile CPU to large GPU clusters. Along the way, a slew of frameworks became available to simplify the tasks of network creation and training. At the same time, other frameworks, notably  PyTorch , offered an imperative programming model that made debugging and execution simpler and easier. TensorFlow 2.0 now defaults to imperative flow (eager execution) and adopts  Keras  as the single high-level API. While these changes modernize TensorFlow&#39;s usability and make it more competitive with PyTorch, it is a significant rewrite that often breaks backward compatibility â€” many tools and serving frameworks in the TensorFlow ecosystem won&#39;t immediately work with the new version. For the time being, consider whether you want to design and experiment in TensorFlow 2.0 but revert to version 1 to serve and run your models in production. Google&#39;s  TensorFlow  is an open source machine-learning platform that can be used for everything from research through to production and will run on hardware from a mobile CPU all the way to a large GPU compute cluster. It&#39;s an important platform because it makes implementing deep-learning algorithms much more accessible and convenient. Despite the hype, though, TensorFlow isn&#39;t really anything new algorithmically: All of these techniques have been available in the public domain via academia for some time. It&#39;s also important to realize that most businesses are not yet doing even basic predictive analytics and that jumping to deep learning likely won&#39;t help make sense of most data sets. For those who do have the right problem and data set, however, TensorFlow is a useful toolkit. 
Creating reliable environments for running automated tests is a perennial problem, particularly as the number of components that modern systems depend on keeps increasing.  Testcontainers  is a Java library that helps mitigate this challenge by managing dockerized dependencies for your tests. This is particularly useful for spinning up repeatable database instances or similar infrastructure, but it can also be used in web browsers for UI testing. Our teams have found this library to be helpful for making integration tests more reliable with these programmable, lightweight and disposable containers. 
Testing Library  is a family of packages for testing applications in numerous frameworks such as  React ,  Vue ,  React Native  and  Angular  among others. This set of libraries helps you test UI components in a user-centric way by encouraging you to test user behavior rather than implementation details, such as the presence of elements in the UI at a certain moment in time. One of the benefits of this mindset is more reliable tests, and this is what we call out as its main differentiator. We recommend you assess this family of libraries when testing your web applications in any framework. Although our direct experience is limited to  React Testing Library  and Angular Testing Library, we&#39;ve been impressed with what we&#39;ve seen. 
Despite the fervor surrounding the spate of new headsets, we believe there are many VR and AR scenarios that make sense in the browser, particularly on mobile. Given this trend, we have seen an uptick in usage of  Three.js , a powerful JavaScript visualization and 3D rendering framework. The growth in support for WebGL, which it is based on, has helped adoption, as has the vibrant community supporting this open source project. Despite the fervor surrounding the spate of new headsets, we believe there are many VR and AR scenarios that make sense in the browser, particularly on mobile. Given this trend, we have seen an uptick in usage of  Three.js , a powerful JavaScript visualization and 3D rendering framework. The growth in support for WebGL, which it is based on, has helped adoption, as has the vibrant community supporting this open source project. 
Building systems using microservices requires us to think more deeply about failure isolation and testing.  TLA+ Â  is a formal specification language that can be useful in both these scenarios. For failure isolation, TLA+ can be used to identify invariants in your system that can be monitored directly. An invariant can be the ratio of number of requests to one service to the number of requests to a second service, for example. Any change in this ratio would lead to an alert. TLA+ is also being used to identify subtle design flaws in distributed systems. Amazon, for example, used model-checking based on a formal specification written in TLA+ to identify subtle bugs in Dynamo DB before it was released to the public. For most systems, the investment required to create the formal specification and then perform model checking is probably too great; however, for critical systems - complex ones, or those with many users - we think itâ€™s very valuable to have another tool in our toolbox. 
Traveling Ruby  makes it possible to distribute portable, ready-to-run, platform-agnostic Ruby binaries without the need to install an interpreter, packages or additional gems. It decouples running Ruby applications from the development environment they run in. 
We&#39;re trying out  troposphere  as a way of defining the  infrastructure as code  on AWS for our projects that use  AWS   CloudFormation  instead of  Terraform . troposphere is a Python library that allows us to write Python code to generate CloudFormation JSON descriptions. What we like about troposphere is that it facilitates catching JSON errors early, applying type checking, and unit testing and DRY composition of AWS resources. Weâ€™re trying out  troposphere  as a way of defining the  infrastructure as code  on AWS for our projects where  AWS   CloudFormation  is used instead of  Terraform . troposphere is a Python library that allows us to write Python code to generate CloudFormation JSON descriptions. What we like about troposphere is that it facilitates catching JSON errors early, applying type checking, and unit testing and DRY composition of AWS resources. 
Truffle  is a development framework that brings a modern web development experience to the  Ethereum  platform. It takes over the job of smart contract compiling, library linking and deployment, as well as dealing with artifacts in different blockchain networks. One of the reasons we love Truffle is that it encourages people to write tests for their smart contracts. You need to take tests really seriously as smart contract programming is often related to money. With its built-in testing framework and integration with  TestRPC , Truffle makes it possible to write the contract in a TDD way. We expect to see more technologies similar to Truffle to promote continuous integration in the blockchain area. Truffle  is a development framework that brings a modern web development experience to the  Ethereum  platform. It takes over the job of smart contract compiling, library linking and deployment, as well as dealing with artifacts in different blockchain networks. One of the reasons we love Truffle is that it encourages people to write tests for their smart contracts. You need to take tests really seriously as smart contract programming is often related to money. With its built-in testing framework and integration with  TestRPC , Truffle makes it possible to write the contract in a TDD way. We expect to see more technologies similar to Truffle to promote continuous integration in the blockchain area. 
With JavaScript development on the rise, there is a growing need for reusable, extensible UI tooling. Twitter Bootstrap builds on the best offerings in the space, to provide a powerful set of patterns and components that help developers create responsive and adaptive applications with pleasant aesthetics. 
TypeScript , a statically typed language and superset of JavaScript, has become our sensible default. Large-scale projects benefit most from the type safety. Our developers favor its minimal configuration management, well-integrated IDE support and its ability to refactor code safely and gradually adopt types. With its  good repository  of TypeScript-type definitions at hand, we benefit from all the rich JavaScript libraries while gaining type safety. TypeScript  is a carefully considered language and its consistently improving tools and IDE support continues to impress us. With a  good repository  of TypeScript-type definitions, we benefit from all the rich JavaScript libraries while gaining type safety. This is particularly important as our browser-based code base continues to grow. The type safety in TypeScript lets you use IDEs and other tools to provide deeper context into your code and make changes and refactor code with safety. TypeScript, being a superset of JavaScript, and documentation and the community has helped ease the learning curve. TypeScript  is an interesting approach to bringing a new programming language to the browser. With TypeScript, the new language features compile down to normal JavaScript, and yet as a superset of JavaScript it does not feel like a completely new language. It does not represent an either-or proposition and it does not relegate JavaScript to an intermediate execution platform. Many of the language features are based on planned future extensions of JavaScript. 
We&#39;re strong proponents of  polyglot programming  but recognize that in some cases it can make sense to focus on a single programming language. If you&#39;re heavily invested in Swift, most likely because of iOS development, and you find yourself looking for a technology to write server-side services, have a look at  Vapor , a modern web framework for Swift that has gained a fair amount of popularity. 
Vue.js  has become one of the successfully applied, loved and trusted frontend JavaScript frameworks among our community. Although there are other, well-adopted alternatives, such as  React.js , the simplicity of Vue.js in API design, its clear segregation of directives and components (one file per component idiom) and its simpler state management have made it a compelling option among others. In the ever-changing world of front-end JavaScript frameworks, one of the emerging favorites appears to be  Vue.js .  Vue.js is a lightweight alternative to  AngularJS . It is designed to be a very flexibleâ€”and a less opinionatedâ€”library that offers a set of tools for building interactive web interfaces around concepts such as modularity, components and reactive data flow. It has a low learning curve, which makes it interesting for less experiencedÂ developers and beginners. Note, though, that Vue.js is not a full-blown framework; it is focused on the view layer only and therefore is easy to integrate with other libraries or existing projects. In the ever-changing world of front-end JavaScript frameworks,  Vue.js  has gained a lot of ground as a lightweight alternative to  AngularJS . It is designed to be a very flexibleâ€”and a less opinionatedâ€”library that offers a set of tools for building interactive web interfaces around concepts like modularity, components and reactive data flow. It has a low learning barrier, which makes it interesting for junior developers and beginners. Vue.js itself is not a full-blown framework; it is focused on the view layer only and therefore is easy to integrate with other libraries or existing projects. 
Until recently, Microsoft&#39;s Web API was the least-worst option for building a RESTful service using ASP.NET. Web API 2 fixes a number of rough edges with better support for flexible routing, sub-resources, media types and improved testability. It continues to be our preferred library for building .NET REST APIs. 
WebAssembly  is a big step forward in the capabilities of the browser as a code execution environment. Supported by all major browsers and backward compatible, it&#39;s a binary compilation format designed to run in the browser at near native speeds. It opens up the range of languages you can use to write front-end functionality, with early focus on C, C++ and Rust, and it&#39;s also an LLVM compilation target. When run in the sandbox, it can interact with JavaScript and shares the same permissions and security model. When used with  Firefox&#39;s new streaming compiler , it also results in faster page initialization. Although it&#39;s still early days, this W3C standard is definitely one to start exploring. WebAssembly  is a big step forward in the capabilities of the browser as a code execution environment. Supported by all major browsers and backward compatible, it&#39;s a binary compilation format designed to run in the browser at near native speeds. It opens up the range of languages you can use to write front-end functionality, with early focus on C, C++ and Rust, and it&#39;s also an LLVM compilation target. When run in the sandbox, it can interact with JavaScript and shares the same permissions and security model. When used with  Firefoxâ€™s new streaming compiler , it also results in faster page initialization. Although it&#39;s still early days, this W3C standard is definitely one to start exploring. 
WebFlux  is the Spring Framework implementation of  Reactive Streams . We see a rise in reactive programming models across our teams in general and the use of WebFlux in teams who are working in the Spring ecosystem. It&#39;s best used in large microservices ecosystems where the high performance of the requests is a major concern. It allows overlapping request processing asynchronously without the complications of using multiple threads. WebFlux uses  Reactor  as its reactive library but it is interoperable with other reactive libraries via Reactive Streams. It uses  Netty  as its underlying high-performance communications engine. Although we encourage using Reactive Streams, adopting this programming model requires a significant shift in thinking. Spring Framework 5, released over a year ago, embraces  reactive streams , a standard for asynchronous stream processing with non-blocking backpressure. The  WebFlux  module introduces a reactive alternative to the traditional Spring MVC module for writing web applications in the Spring ecosystem. After working with it on a number of applications, our teams have come away impressed and report that the reactive (functional) approach improves code readability and system throughput. They do note, though, that adopting WebFlux requires a significant shift in thinking and recommend to factor this into the decision to choose WebFlux over Spring MVC. 
Widespread adoption of AR/VR as a collaboration and communication medium requires a modern and readily available video streaming platform.  WebRTC  is an emerging standard for real-time communication between browsers that enables video streaming within commonly available web technologies. The range of browsers that support this standard is increasing, but Microsoft and Apple have been slow to adopt WebRTC in their proprietary browsers. If momentum continues to build, WebRTC could form the future foundation for AR/VR collaboration on the web. Widespread adoption of AR/VR as a collaboration and communication medium requires a modern and readily available video streaming platform.  WebRTC  is an emerging standard for real-time communication between browsers that enables video streaming within commonly available web technologies. The range of browsers that support this standard is increasing, but Microsoft and Apple have been slow to adopt WebRTC in their proprietary browsers. If momentum continues to build, WebRTC could form the future foundation for AR/VR collaboration on the web. 
Weex  is a framework for building cross-platform mobile apps by using the  Vue.js  component syntax. For those who prefer the simplicity of Vue.js, Weex is a viable option for native mobile apps, but it also works very well for more complicated apps. We see many successes for fairly complicated mobile apps built on this framework, including  TMall  and  Taobao , two of the most popular mobile apps in China. Weex was developed by Alibaba, and is now an  Apache incubator project . 
The Golang community has had its fair share of dependency injection skeptics, partly because they confused the  pattern  with specific frameworks, and developers with a system-programming background naturally dislike runtime overhead caused by reflection. Then along came  Wire , a compile-time dependency injection tool that can generate code and wire components together. Wire has no additional runtime overhead, and the static dependency graph is easier to reason about. Whether you handwrite your code or use frameworks, we recommend using dependency injection to encourage modular and testable designs. 
We are intrigued by the possibilities offered by the  Wolfram language . Building on the symbolic approaches of the Mathematica language it also has access to a vast array of algorithms and data from the Wolfram Alpha project, which means that very succinct programs can analyze and visualize powerful combinations of real-world data. 
We&#39;ve featured several state management libraries in the Radar before, but  XState  takes a slightly different approach. It&#39;s a simple JavaScript and  TypeScript  framework for creating finite state machines and visualizing them as state charts. It integrates with the more popular reactive JavaScript frameworks ( Vue.js ,  Ember.js ,  React.js  and  RxJS ) and is based on the W3C standard for finite state machines. Another notable feature is the serialization of machine definitions. One thing that we&#39;ve found helpful when creating finite state machines in other contexts (particularly when writing game logic) is the ability to visualize states and their possible transitions; we like that it&#39;s really easy to do this with XState&#39;s  visualizer . We&#39;ve featured several state management libraries in the Radar before, but  XState  takes a slightly different approach. It&#39;s a simple JavaScript and  TypeScript  framework for creating finite state machines and visualizing them as state charts. It integrates with the more popular reactive JavaScript frameworks ( Vue.js ,  Ember.js ,  React.js  and  RxJS ) and is based on the W3C standard for finite state machines. Another notable feature is the serialization of machine definitions. One thing that we&#39;ve found helpful when creating finite state machines in other contexts (particularly when writing game logic) is the ability to visualize states and their possible transitions; we like the fact that it&#39;s really easy to do this with XState&#39;s  visualizer . 
Yeoman attempts to make web application developers more productive by simplifying activities like scaffold, build and package management. It is a collection of the tools Yo, Grunt and Bower that work well as a set. 
